(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
prong = require('./prong/');
},{"./prong/":28}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2

/*
 thins out the data by taking chunks of samples at a time
 and applying an aggregating function to them. The aggregator function is
 optional, and will default to d3.max. So, for example if thinningFactor = 4
 and aggregator = d3.max, then the return value will be an array with 1/4 the
 number of elements, each element being the maximum of a group of 4 of the
 original array.
 */

(function() {
  var aggregatorByName, d3, downsampleMax;

  d3 = require('d3-prong');

  aggregatorByName = {
    'max': d3.max,
    'first': function(d) {
      return d[0];
    }
  };

  downsampleMax = function(data, thinningFactor) {
    var abs, i, j, max, maxAbs, n, thinnedArray;
    thinnedArray = [];
    i = -1;
    j = 0;
    n = data.length;
    max = 0;
    maxAbs = 0;
    while (++i < n) {
      abs = Math.abs(data[i]);
      if (abs > maxAbs) {
        maxAbs = abs;
        max = data[i];
      }
      j++;
      if (j === thinningFactor) {
        j = 0;
        thinnedArray.push(max);
        max = 0;
        maxAbs = 0;
      }
    }
    return thinnedArray;
  };

  module.exports = function(data, thinningFactor, aggregator) {
    var i, k, ref, ref1, thinnedArray;
    if (aggregator == null) {
      aggregator = d3.max;
    }
    if (thinningFactor === 1) {
      return data;
    }
    if (aggregator in aggregatorByName) {
      aggregator = aggregatorByName[aggregator];
    }
    if (aggregator === d3.max) {
      return downsampleMax(data, thinningFactor);
    }
    thinnedArray = [];
    for (i = k = 0, ref = data.length, ref1 = thinningFactor; ref1 > 0 ? k < ref : k > ref; i = k += ref1) {
      thinnedArray.push(aggregator(data.slice(i, i + thinningFactor)));
    }
    return thinnedArray;
  };

}).call(this);

},{"d3-prong":46}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2

/*
A function for caching and retrieving downsampled versions of waveforms. All 
the data and settings are stored as properties of the @d object. It is expected 
to have the following keys

    d._buffer - the audio buffer
    d._channel - the audio channel

This function will make use of d._cache to store downsampled versions of the 
waveform, so that subsequent calls can be returned quicker

@start the time, in seconds', into the clip where the result should start
@end the time in seconds into the clip where the result should end
@pixelWidth the minimum number of samples you want to represent this waveform
 */

(function() {
  var ZOOM_LEVELS, downsample;

  downsample = require('./downsample');

  ZOOM_LEVELS = [5000, 1000];

  module.exports = function(d, viewDomain, pixelWidth) {
    var channel, data, end, i, j, len, len1, length, level, sampleEnd, sampleOffset, sampleRate, sampleStart, samplesPerPixel, start;
    start = viewDomain[0], end = viewDomain[1];
    sampleOffset = d._buffer.sampleOffset || 0;
    channel = d._channel;
    sampleRate = d._buffer.sampleRate;
    length = end - start;
    if (!('_cache' in d)) {
      d._cache = {};
      for (i = 0, len = ZOOM_LEVELS.length; i < len; i++) {
        level = ZOOM_LEVELS[i];
        d._cache[level] = downsample(channel, level);
      }
    }
    samplesPerPixel = Math.max(~~(length * sampleRate / pixelWidth), 1);
    sampleStart = (start * sampleRate) + sampleOffset;
    sampleEnd = (end * sampleRate) + sampleOffset;
    for (j = 0, len1 = ZOOM_LEVELS.length; j < len1; j++) {
      level = ZOOM_LEVELS[j];
      if (samplesPerPixel > level) {
        return [d._cache[level].slice(sampleStart / level, sampleEnd / level), level];
      }
    }
    data = channel.subarray(sampleStart, sampleEnd);
    return [downsample(data, samplesPerPixel), samplesPerPixel];
  };

}).call(this);

},{"./downsample":2}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var audioContext;

  audioContext = null;

  module.exports = function() {
    var e;
    if (audioContext) {
      return audioContext;
    }
    try {
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      audioContext = new AudioContext();
      return audioContext;
    } catch (_error) {
      e = _error;
      return alert('Web Audio API is not supported in this browser');
    }
  };

}).call(this);

},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var UserAgent, offsets, userAgent;

  UserAgent = require('./userAgent');

  userAgent = new UserAgent();

  offsets = {
    'mp3': {
      'chrome': 1057,
      'firefox': 528
    }
  };

  module.exports = function(url) {
    var type;
    type = url.split('.').pop();
    if (type in offsets) {
      if (userAgent.browser_name in offsets[type]) {
        return offsets[type][userAgent.browser_name];
      }
    }
    return 0;
  };

}).call(this);

},{"./userAgent":43}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  module.exports = function() {
    var buffer, commonProperties, height, historyKey, sequence, timeline, width, x;
    x = null;
    buffer = null;
    width = null;
    height = null;
    timeline = null;
    sequence = null;
    historyKey = null;
    commonProperties = {};
    commonProperties.x = function(_x) {
      if (!arguments.length) {
        return x;
      }
      x = _x;
      return commonProperties;
    };
    commonProperties.width = function() {
      return Math.abs(x.range()[1] - x.range()[0]);
    };
    commonProperties.height = function(_height) {
      if (!arguments.length) {
        return height;
      }
      height = _height;
      return commonProperties;
    };
    commonProperties.sequence = function(_sequence) {
      if (!arguments.length) {
        return sequence;
      }
      sequence = _sequence;
      return commonProperties;
    };
    commonProperties.timeline = function(_timeline) {
      if (!arguments.length) {
        return timeline;
      }
      timeline = _timeline;
      return commonProperties;
    };
    commonProperties.historyKey = function(_historyKey) {
      if (!arguments.length) {
        return historyKey;
      }
      historyKey = _historyKey;
      return commonProperties;
    };
    return commonProperties;
  };

}).call(this);

},{}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var commonProperties, uid;

  commonProperties = require('../commonProperties');

  uid = require('../uid');

  module.exports = function() {
    var DISPLAY_ABOVE_AND_BELOW_CUTOFF, DISPLAY_AS_LINE_CUTOFF, MEDIUM_ZOOM, WIDE_ZOOM, startOffset, verticalZoom, waveform;
    startOffset = 0;
    verticalZoom = 1;
    DISPLAY_ABOVE_AND_BELOW_CUTOFF = 10;
    DISPLAY_AS_LINE_CUTOFF = 1;
    WIDE_ZOOM = 5000;
    MEDIUM_ZOOM = 1000;
    waveform = function() {
      var draw, drawAndTime, drawingTime, lastDrawingStart, lastTimeout, selection, timeline;
      selection = this;
      draw = function() {
        return selection.each(function(d) {
          var canvas, channel, clipDomain, clipRange, clipScale, clipStart, context, data, domain, height, i, j, length, range, ref, sampleRate, sampleX, samplesPerPixel, sel, translateX, viewEnd, viewStart, width, x, y;
          sel = d3.select(this);
          d.startTime = d.startTime || 0;

          /* there are essentially two scales at play
              1. clipScale - this maps the sequence timeline
              to the clip timeline. It can also be used to determine which
              time slices of the channel are actually visible. The domain
              and range will be shrunk to fit what's actually visible
          
              2. sequenceScale - this maps the time of the sequence to the
              pixels on the screen - the normal x scale. The domain is
              sequence time and the range is pixels on screen.
          
              by combining the two, we can map clip time to pixels
           */
          x = waveform.x();
          domain = x.domain();
          range = x.range();
          channel = d._channel;
          sampleRate = d._buffer.sampleRate;
          startOffset = d.startTime || 0;
          length = null;
          d.clipStart = d.clipStart || 0;
          d.clipEnd = d.clipEnd || (channel.length / sampleRate);
          length = d.clipEnd - d.clipStart;
          clipDomain = [d.clipStart, d.clipEnd];
          clipRange = [d.startTime, d.startTime + length];
          clipScale = d3.scale.linear().range(clipRange).domain(clipDomain);
          clipStart = d.clipStart;
          viewStart = clipStart + Math.max(domain[0] - d.startTime, 0);
          viewEnd = d.clipEnd - Math.max(d.startTime + length - domain[1], 0);
          sel.selectAll('.area').remove();
          sel.selectAll('.line').remove();
          if (viewStart > viewEnd) {
            return;
          }
          width = waveform.width();
          height = waveform.height() || 128;
          samplesPerPixel = Math.max(~~((Math.abs(domain[1] - domain[0]) * sampleRate) / width), 1);
          if (!('_cache' in d)) {
            d._cache = {};
          }
          data = null;
          if (!(WIDE_ZOOM in d._cache)) {
            d._cache[WIDE_ZOOM] = fx.thinOut(channel, WIDE_ZOOM);
          }
          if (!(MEDIUM_ZOOM in d._cache)) {
            d._cache[MEDIUM_ZOOM] = fx.thinOut(channel, MEDIUM_ZOOM);
          }
          if (samplesPerPixel >= WIDE_ZOOM) {
            samplesPerPixel = WIDE_ZOOM;
            data = d._cache[WIDE_ZOOM].slice(viewStart * sampleRate / WIDE_ZOOM, viewEnd * sampleRate / WIDE_ZOOM);
          } else if (samplesPerPixel >= MEDIUM_ZOOM) {
            samplesPerPixel = MEDIUM_ZOOM;
            data = d._cache[MEDIUM_ZOOM].slice(viewStart * sampleRate / MEDIUM_ZOOM, viewEnd * sampleRate / MEDIUM_ZOOM);
          } else {
            data = channel.subarray(viewStart * sampleRate, viewEnd * sampleRate);
            data = fx.thinOut(data, samplesPerPixel, samplesPerPixel > DISPLAY_ABOVE_AND_BELOW_CUTOFF ? 'max' : 'first');
          }
          y = d3.scale.linear().range([height, 0]).domain([1 / verticalZoom, -1 / verticalZoom]);
          translateX = 0;
          sampleX = function(d, i) {
            return x(clipScale(i * samplesPerPixel / sampleRate + viewStart));
          };
          if (samplesPerPixel > DISPLAY_AS_LINE_CUTOFF) {
            canvas = sel.node();
            context = canvas.getContext('2d');
            context.clearRect(0, 0, 800, 200);
            context.beginPath();
            data.forEach(function(d, i) {
              return context.lineTo(sampleX(d, i), y(-d));
            });
            for (i = j = ref = data.length - 1; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
              d = data[i];
              context.lineTo(sampleX(d, i), y(d));
            }
            context.closePath();
            context.fillStyle = 'steelblue';
            return context.fill();
          } else {
            return console.log('canvas line mode not done yet');
          }
        });
      };
      draw();
      timeline = waveform.timeline();
      if (timeline) {
        lastTimeout = null;
        drawingTime = null;
        lastDrawingStart = null;
        drawAndTime = function() {
          var start;
          start = new Date();
          draw();
          return drawingTime = new Date() - start;
        };
        return timeline.on('change.' + uid(), function() {
          var after;
          if (lastTimeout) {
            clearTimeout(lastTimeout);
          }
          if ((!lastDrawingStart) || (new Date() - lastDrawingStart) > (drawingTime * 2)) {
            return drawAndTime();
          } else {
            after = function() {
              drawAndTime();
              return lastTimeout = null;
            };
            return lastTimeout = setTimeout(after, 50);
          }
        });
      }
    };
    waveform.verticalZoom = function(_verticalZoom) {
      if (!arguments.length) {
        return verticalZoom;
      }
      verticalZoom = _verticalZoom;
      return waveform;
    };
    return d3.rebind(waveform, commonProperties(), 'x', 'width', 'height', 'timeline');
  };

}).call(this);

},{"../commonProperties":6,"../uid":42}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var commonProperties, editListCodec, history, uid;

  commonProperties = require('../commonProperties');

  uid = require('../uid');

  history = require('../history/history');

  editListCodec = require('../history/editListCodec');

  module.exports = function() {
    var cleanup, compStart, comper, dispatch, draw, editAtTime, editList, historyId, historyTracker, inbetweens, liveTrackAtTime, nextInArray, previousInArray, selection;
    editList = [
      {
        'track': 0,
        start: 0
      }
    ];
    selection = null;
    dispatch = d3.dispatch('change');
    historyId = null;
    historyTracker = null;
    inbetweens = function(track, edits, x) {
      var edit, end, i, j, ref, regions, start;
      start = x.domain()[0];
      end = x.domain()[1];
      if (edits.length === 0) {
        return [
          {
            'track': track,
            'start': start,
            'end': end
          }
        ];
      }
      regions = [];
      if (edits[0].start > start) {
        regions.push({
          'track': track,
          'start': start,
          'end': edits[0].start
        });
      }
      for (i = j = 0, ref = edits.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        edit = edits[i];
        regions.push({
          'track': track,
          'start': edits[i].end,
          'end': edits[i + 1].start
        });
      }
      if (edits[edits.length - 1].end < end) {
        regions.push({
          'track': track,
          'start': edits[edits.length - 1].end,
          'end': end
        });
      }
      return regions;
    };
    nextInArray = function(array, element) {
      var index;
      index = array.indexOf(element);
      if (index === -1) {
        return null;
      }
      if (index === array.length - 1) {
        return null;
      }
      return array[index + 1];
    };
    previousInArray = function(array, element) {
      var index;
      index = array.indexOf(element);
      if (index === -1) {
        return null;
      }
      if (index === 0) {
        return null;
      }
      return array[index - 1];
    };
    editAtTime = function(time) {
      var edit, i, j, ref;
      for (i = j = 0, ref = editList.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        edit = editList[i];
        if (edit.start <= time && edit.end > time) {
          return edit;
        }
      }
      return null;
    };
    liveTrackAtTime = function(time) {
      var edit;
      edit = editAtTime(time);
      if (edit) {
        return edit.track;
      } else {
        return null;
      }
    };
    compStart = function() {
      var compMove, compUp, edit, eventTarget, mode, mouse, nextEdit, offset, previousEdit, previousTime, removeNextEdit, removePreviousEdit, resizing, target, w, x;
      target = this;
      eventTarget = d3.select(d3.event.target);
      offset = null;
      edit = eventTarget.datum();
      nextEdit = nextInArray(editList, edit);
      previousEdit = previousInArray(editList, edit);
      mode = (function() {
        switch (false) {
          case !eventTarget.classed('start'):
            return 'start';
          case !eventTarget.classed('end'):
            return 'end';
          case !eventTarget.classed('comp'):
            return 'dragging';
          case !eventTarget.classed('inbetween'):
            return 'swiping';
          default:
            return null;
        }
      })();
      resizing = mode === 'start' || mode === 'end';
      mouse = function() {
        var touches;
        touches = d3.event.changedTouches;
        if (touches) {
          return d3.touches(target, touches)[0];
        } else {
          return d3.mouse(target);
        }
      };
      x = comper.x();
      previousTime = x.invert(mouse()[0]);
      removeNextEdit = function() {
        editList.remove(nextEdit);
        nextEdit = nextInArray(editList, edit);
        if (nextEdit && (nextEdit.track === edit.track)) {
          return editList.remove(nextEdit);
        }
      };
      removePreviousEdit = function() {
        editList.remove(previousEdit);
        previousEdit = previousInArray(editList, edit);
        if (previousEdit && (previousEdit.track === edit.track)) {
          return editList.remove(edit);
        }
      };
      compMove = function() {
        var bittenEdit, bittenTrack, diff, endEdit, lowerLimit, moved, time;
        time = x.invert(mouse()[0]);
        moved = false;
        lowerLimit = x.invert(2) - x.invert(0);
        switch (mode) {
          case 'start':
            if (time > edit.end - lowerLimit) {
              time = edit.end - lowerLimit;
            }
            time = Math.max(0, time);
            if (previousEdit && (time <= previousEdit.start)) {
              removePreviousEdit();
            }
            edit.start = time;
            break;
          case 'end':
            if (time < edit.start + lowerLimit) {
              time = edit.start + lowerLimit;
            }
            if (nextEdit) {
              if (time > nextEdit.end) {
                removeNextEdit();
              }
              if (nextEdit) {
                nextEdit.start = time;
              }
            } else {
              edit.end = time;
            }
            break;
          case 'dragging':
            diff = time - previousTime;
            if (editList.indexOf(edit) !== 0) {
              edit.start += diff;
            }
            if (nextEdit) {
              nextEdit.start += diff;
              if (nextEdit.start > nextEdit.end) {
                removeNextEdit();
              }
            }
            if (previousEdit && (edit.start < previousEdit.start)) {
              removePreviousEdit();
            }
            previousTime = time;
            break;
          case 'swiping':
            if (Math.abs(x(time) - x(previousTime)) < 4) {
              return;
            }
            mode = time > previousTime ? 'end' : 'start';
            bittenEdit = editAtTime(time);
            if (!bittenEdit) {
              return;
            }
            bittenTrack = bittenEdit.track;
            if (mode === 'start') {
              edit = {
                'track': edit.track,
                'start': time
              };
              editList.push(edit);
              endEdit = {
                'track': bittenTrack,
                'start': previousTime
              };
              if (bittenEdit.end) {
                endEdit.end = bittenEdit.end;
              }
              editList.push(endEdit);
            } else {
              edit = {
                'track': edit.track,
                'start': previousTime
              };
              nextEdit = {
                'track': bittenTrack,
                'start': time
              };
              editList.push(edit);
              editList.push(nextEdit);
              if (bittenEdit.end) {
                nextEdit.end = bittenEdit.end;
              }
            }
            editList.sort(function(a, b) {
              return a.start - b.start;
            });
            previousEdit = previousInArray(editList, edit);
        }
        cleanup();
        return draw();
      };
      compUp = function() {
        var editToMove, trackClicked;
        w.on('mousemove.comp', null).on('mouseup.comp', null);
        if (mode === 'swiping') {
          trackClicked = edit.track;
          editToMove = editAtTime(previousTime);
          editToMove.track = trackClicked;
          cleanup();
          draw();
        }
        dispatch.change();
        if (historyTracker) {
          return historyTracker.set(editList, 'change edit');
        }
      };
      return w = d3.select(window).on('mousemove.comp', compMove).on('mouseup.comp', compUp);
    };
    cleanup = function() {
      return selection.each(function() {
        var track;
        track = d3.select(this);
        track.selectAll('rect.comp').remove();
        track.selectAll('rect.start').remove();
        track.selectAll('rect.end').remove();
        return track.selectAll('rect.inbetween').remove();
      });
    };
    draw = function() {
      var domain, end, filteredEditList, height, range, start, width, x;
      x = comper.x();
      domain = x.domain();
      range = x.range();
      end = domain[1];
      editList.forEach(function(d, i) {
        return d.end = i < (editList.length - 1) ? editList[i + 1].start : d.end || end;
      });
      filteredEditList = editList.filter(function(d, i) {
        return d.end > domain[0] && d.start < domain[1];
      });
      start = function(d) {
        return Math.max(x(d.start), range[0]);
      };
      width = function(d) {
        return Math.max(Math.min(x(d.end), range[1]) - start(d) - 1, 0);
      };
      height = comper.height();
      return selection.each(function(d, i) {
        var edits, track;
        edits = filteredEditList.filter(function(d) {
          return d.track === i;
        });
        track = d3.select(this);
        track.style("pointer-events", "all").on("mousedown.comp", compStart).on("touchstart.comp", compStart);
        track.selectAll('rect.comp').data(edits).enter().append('rect').attr('x', start).attr('width', width).attr('y', 0).attr('height', height).attr('class', 'comp');
        track.selectAll('rect.inbetween').data(inbetweens(i, edits, x)).enter().append('rect').attr('x', start).attr('width', width).attr('y', 0).attr('height', height).attr('class', 'inbetween');
        track.selectAll('rect.start').data(edits).enter().append('rect').attr('x', function(d) {
          return x(d.start) - 5;
        }).attr('width', 10).attr('y', 0).attr('height', height + 1).attr('class', function(d) {
          var first;
          first = editList.indexOf(d) === 0;
          return 'resizer start ' + (first ? 'first' : '');
        });
        return track.selectAll('rect.end').data(edits).enter().append('rect').attr('x', function(d) {
          return x(d.end) - 5;
        }).attr('width', 10).attr('y', 0).attr('height', height + 1).attr('class', function(d) {
          var last;
          last = editList.indexOf(d) === editList.length - 1;
          return 'resizer end ' + (last ? 'last' : '');
        });
      });
    };
    comper = function(_selection) {
      var timeline;
      selection = _selection;
      if (historyId) {
        historyTracker = history(historyId, editListCodec);
        historyTracker.on('change', function(value) {
          editList = value;
          return comper.redraw();
        });
        editList = historyTracker.get();
      }
      cleanup();
      draw();
      timeline = comper.timeline();
      if (timeline) {
        return timeline.on('change.' + uid(), function(x) {
          return comper.x(x).redraw();
        });
      }
    };
    comper.liveTrackAtTime = liveTrackAtTime;
    comper.editList = function(_editList) {
      if (!arguments.length) {
        return editList;
      }
      editList = _editList;
      return comper;
    };
    comper.redraw = function() {
      cleanup();
      return draw();
    };
    comper.history = function(_history) {
      if (!arguments.length) {
        return historyId;
      }
      if (!_history) {
        historyId = null;
      } else {
        if (_history === true) {
          _history = 'comper-' + uid();
        }
        historyId = _history;
      }
      return comper;
    };
    comper.on = function(type, listener) {
      return dispatch.on(type, listener);
    };
    comper = d3.rebind(comper, commonProperties(), 'x', 'timeline', 'height');
    comper.height(128);
    return comper;
  };

}).call(this);

},{"../commonProperties":6,"../history/editListCodec":26,"../history/history":27,"../uid":42}],9:[function(require,module,exports){
var commonProperties = require('../commonProperties'),
    //fx = require('../analysis/fx'),
    uid = require('../uid');

// a contour is very similar to a waveform, but usually at a much lower sample
// rate. i.e. it is a component for drawing a regularly spaced time series
// of values
module.exports = function(){ 
    var startOffset = 0,
        sampleRate,
        label = null;

    var contour = function(){

        var selection = this;

        function draw(){

            selection.each(function(d,i){
                
                var sel = d3.select(this),
                    firstOffset = d.firstOffset || 0,
                    x = contour.x(),
                    domain = x.domain(),
                    range = x.range(),
                    startOffset = d.startTime || 0;

                x = d3.scale.linear().range(range).domain([domain[0] - startOffset, domain[1] - startOffset])

                var width = contour.width(),
                    height = contour.height() || 128,
                    startTime = Math.max(x.domain()[0],0);

                // trim the data according to the range of the x scale
                var data = d.slice(startTime * sampleRate - firstOffset, domain[1] * sampleRate - firstOffset);

                //data = data.slice(startTime * sampleRate, domain[1] * sampleRate);
                var reverseData = d.slice(0, startTime * sampleRate - firstOffset)


                var y = d3.scale.linear()
                    .range([height, 0])
                    .domain([0,1]);

                var translateX = 0;

                function sampleX(d, i){
                    return x(i/sampleRate + startTime);
                }

                sel.text('');
      
                var line = d3.svg.line()
                    .x(sampleX)
                    .y(y)
                    .interpolate('linear');

                sel.append('g')
                    .attr('class','line')
                    .attr('transform','translate('+translateX+',0)')
                    .append('path')
                    .datum(data)
                    .attr('d', line);

                // function reverseSampleX(d, i){
                //     return x((reverseData.length - i)/sampleRate + startTime);
                // }

                // var reverseLine = d3.svg.line()
                //     .x(reverseSampleX)
                //     .y(y)
                //     .interpolate('linear');

                // sel.append('g')
                //     .attr('class','line')
                //     .attr('transform','translate('+translateX+',0)')
                //     .append('path')
                //     .attr('stroke','red')
                //     .datum(reverseData)
                //     .attr('d', reverseLine);


                sel.append('text')
                    .attr('x',10)
                    .attr('y', height/2)
                    .text(label && label(d,i))

            })
        }

        draw();

        var timeline = contour.timeline();

        if (timeline){
            // this timing logic tries to keep contour redrawing as smooth
            // as possible. It times how long it takes to redraw the contour
            // and makes sure not to redraw more frequently than that

            var lastTimeout = null,
                drawingTime = null,
                lastDrawingStart = null;

            function drawAndTime(){
                var start = new Date();
                draw();
                drawingTime = new Date() - start;
            }

            timeline.on('change.' + uid(), function(){
                if (lastTimeout) clearTimeout(lastTimeout);
                if (!lastDrawingStart || (new Date() - lastDrawingStart) > (drawingTime * 2)){
                    drawAndTime();
                }else{
                    lastTimeout = setTimeout(function(){
                        drawAndTime();
                        lastTimeout = null;
                    }, 50);  
                }    
            })
        }
    }

    contour.label = function(_label){
        if (!arguments.length) return label;
        label = _label;
        return contour;
    }

    contour.sampleRate = function(_sampleRate){
        if (!arguments.length) return sampleRate;
        sampleRate = _sampleRate;
        return contour;
    }

    // inherit properties from the commonProperties
    return d3.rebind(contour, commonProperties(), 'x', 'width', 'height', 'timeline');
}
},{"../commonProperties":6,"../uid":42}],10:[function(require,module,exports){
var commonProperties = require('../commonProperties'),
    uid = require('../uid');

module.exports = function(){

    var video; 

    function setup(d, video, canvas, offsetTime, callback){
        var x = filmstrip.x(),
            range = x.range(),
            domain = x.domain(),
            startOffset = d.startTime || 0;

        x = d3.scale.linear().range(range).domain([domain[0] - startOffset, domain[1] - startOffset])

        var height = filmstrip.height(),
            width = filmstrip.width(),
            drawingContext = canvas.node().getContext('2d'),
            startTime = Math.max(x.domain()[0], offsetTime),
            endTime = Math.min(x.domain()[1], video.duration + offsetTime),
            endX = x(endTime),
            aspectRatio = video.videoWidth / video.videoHeight,
            thumbnailWidth = aspectRatio * height,
            drawingWidth = x(endTime) - x(startTime),
            frames = drawingWidth / thumbnailWidth,
            times = d3.range(startTime, endTime, (endTime - startTime) / frames),
            index = 0,
            time;

        // clear the canvas
        canvas.node().width = canvas.node().width;

        function seeked(){
            var drawX = x(time);
            if ((drawX + thumbnailWidth) < endX){
                drawingContext.drawImage(video, drawX, 0, thumbnailWidth, height);
            }else{
                var fractionToDraw = (endX - drawX) / thumbnailWidth;
                drawingContext.drawImage(video, 0, 0, 
                    video.videoWidth * fractionToDraw, video.videoHeight, 
                    drawX, 0, thumbnailWidth * fractionToDraw, height);
            }
            nextFrame();
        }

        function nextFrame(){
            if (index > (times.length - 1)){
                video.removeEventListener('seeked', seeked);
                if (callback) callback();
            }
            time = times[index];
            index++;
            video.currentTime = time || 0;
        }
        video.addEventListener('seeked', seeked);
        nextFrame();
    }

    function filmstrip(selection){

        var videoNode = video.node();

        selection.each(function(d,i){
            var target = this,
                div = d3.select(this),
                width = filmstrip.width(),
                height = filmstrip.height();

            // we create a hidden video tag, then seek through it and pick out
            // frames to show
            var canvas = div.append('canvas')
                        .attr('height', height)
                        .attr('width',width)
                        .style('position','absolute')
                        .style('left','0px')
                        .attr('class','filmstrip');

            setTimeout(function(){
                if (videoNode.readyState >= videoNode.HAVE_METADATA){
                    setup(d, videoNode, canvas, 0)
                }else{
                    videoNode.addEventListener('loadeddata', function(){
                        setup(d, videoNode, canvas, 0)
                    })
                }
            }, 0)

            var timeline = filmstrip.timeline();

            if (timeline){
                // since it takes a while to redraw the filmstrip, we make sure
                // there's a delay since the last change event
                var lastTimeout = null;

                function redraw(){
                    if (video.node().paused){
                        setup(d, videoNode, canvas, 0);
                        lastTimeout = null;
                    }else{
                        lastTimeout = setTimeout(redraw, 400);
                    }
                }
                
                timeline.on('change.' + uid(), function(){
                    if (lastTimeout){
                        clearTimeout(lastTimeout);
                    }
                    lastTimeout = setTimeout(redraw, 400);       
                })
            }
        });
    }

    filmstrip.video = function(_video){
        if (!arguments.length) return video;
        video = _video;
        return filmstrip;
    }

    return d3.rebind(filmstrip, commonProperties(), 'x', 'width', 'height', 'timeline');
}
},{"../commonProperties":6,"../uid":42}],11:[function(require,module,exports){
// this is the visual component which is used to draw the note onset lines
var commonProperties = require('../commonProperties'),
    uid = require('../uid');

module.exports = function(){
    var key,
        colour,
        labels = false; // boolean, determines whether to show labels

    var lines = function(){
        var selection = this;
        var startOffset = 0;

        function draw(_x){

            selection.each(function(d){

                var sel = d3.select(this);

                var x = _x || lines.x(),
                    width = lines.width(),
                    height = lines.height() || 128,
                    domain = x.domain(),
                    range = x.range(),
                    startOffset = d.startTime || 0;
                    times = sel.datum()[key] || [];

                x = d3.scale.linear().range(range).domain([domain[0] - startOffset, domain[1] - startOffset])

                var startTime = Math.max(x.domain()[0],0);
                
                var visibleTimes = times.filter(function(time){
                    return time > startTime && time < domain[1];
                })

                sel.selectAll('.onset').remove()
                
                // now draw the new ones
                sel.selectAll('.onset')
                    .data(visibleTimes)
                    .enter()
                    .append('rect')
                    .attr('class','onset')
                    .style('fill',colour)
                    .attr('x', function(d){
                        //return x(d + track.startTime);
                        return x(d)
                    })
                    .attr('width',1)
                    .attr('y', 0)
                    .attr('height', height)

                if (labels){
                    var yOffset = times.indexOf(visibleTimes[0]) % 3;
                    sel.selectAll('text').remove()
                    sel.selectAll('text')
                        .data(visibleTimes)
                        .enter()
                        .append('text')
                        .style('fill',colour)
                        .style('font-size','10pt')
                        .attr('x', function(d){
                            return x(d)+1
                        })
                        .attr('width',1)
                        .attr('y', function(d,i){return ((i+yOffset)%3) * 14 + 15})
                        .attr('height', height)
                        .text(function(d){return d3.round(d,2)})
                }
            })
        }

        draw();

        var timeline = lines.timeline();

        if (timeline){
            // this timing logic tries to keep waveform redrawing as smooth
            // as possible. It times how long it takes to redraw the waveform
            // and makes sure not to redraw more frequently than that

            var lastTimeout = null,
                drawingTime = null,
                lastDrawingStart = null;

            function drawAndTime(){
                var start = new Date();
                draw();
                drawingTime = new Date() - start;
            }

            timeline.on('change.' + uid(), function(){
                if (lastTimeout) clearTimeout(lastTimeout);
                if (!lastDrawingStart || (new Date() - lastDrawingStart) > (drawingTime * 2)){
                    drawAndTime();
                }else{
                    lastTimeout = setTimeout(function(){
                        drawAndTime();
                        lastTimeout = null;
                    }, 50);  
                }    
            })
        }
    }

    lines.key = function(_key){
        if (!arguments.length) return key;
        key = _key;
        return lines;
    }

    lines.labels = function(_labels){
        if (!arguments.length) return labels;
        labels = _labels;
        return lines;
    }

    lines.colour = function(_colour){
        if (!arguments.length) return colour;
        colour = _colour;
        return lines;
    }

    // inherit properties from the commonProperties
    return d3.rebind(lines, commonProperties(), 'x', 'width', 'height', 'timeline');
}
},{"../commonProperties":6,"../uid":42}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var commonProperties, d3;

  d3 = require('d3-prong');

  commonProperties = require('../commonProperties');

  module.exports = function() {
    var disabled, dispatch, dragBar, dragEndBar, dragStartBar, draw, loopLeft, loopRight, loopSelector, selection, stopPropagation, updateDragBar, xPosition;
    dispatch = d3.dispatch('change', 'changing');
    loopLeft = null;
    loopRight = null;
    dragBar = null;
    dragStartBar = null;
    dragEndBar = null;
    disabled = false;
    selection = null;
    xPosition = function(node) {
      return loopSelector.timeline().x().invert(d3.mouse(node)[0]);
    };
    stopPropagation = function() {
      var e;
      if (d3.event) {
        e = d3.event.sourceEvent || d3.event;
        e.preventDefault();
        return e.stopPropagation();
      }
    };
    updateDragBar = function() {
      var e, end, endsWidth, ref, s, start, width, x;
      if (!dragBar) {
        return;
      }
      x = loopSelector.timeline().x();
      ref = x.range(), s = ref[0], e = ref[1];
      start = Math.max(s, x(loopLeft));
      end = Math.min(e, x(loopRight));
      width = Math.max(end - start, 0);
      endsWidth = Math.max(1, Math.min(width / 4, 10));
      dragBar.attr('x', start).attr('width', width).classed('disabled', disabled);
      dragStartBar.attr('x', start).attr('width', endsWidth);
      return dragEndBar.attr('x', end - endsWidth).attr('width', endsWidth);
    };
    draw = function(selection) {
      var barDrag, barEndDrag, barStartDrag, drag, dragDelta, dragend, dragendOnDragBar, dragmove, dragstart, dragstartOnDragBar, dragstartTime, drawDragBar, mousedownHandler, mouseupHandler, movedSinceMousedown, width, x;
      dragBar = null;
      dragStartBar = null;
      dragEndBar = null;
      x = loopSelector.timeline().x();
      width = x.range()[1] - x.range()[0];
      movedSinceMousedown = false;
      selection.on('dblclick', stopPropagation);
      drawDragBar = function() {
        dragBar = selection.append('rect').attr('class', 'loop').attr('y', -20).attr('height', '20').call(barDrag);
        dragStartBar = selection.append('rect').attr('class', 'loopStart').attr('y', -20).attr('height', '20').attr('width', 10).call(barStartDrag);
        dragEndBar = selection.append('rect').attr('class', 'loopEnd').attr('y', -20).attr('height', '20').attr('width', 10).call(barEndDrag);
        updateDragBar();
        return dragBar.on('mousedown', mousedownHandler).on('mouseup', mouseupHandler);
      };
      mousedownHandler = function() {
        return movedSinceMousedown = false;
      };
      mouseupHandler = function() {
        if (!movedSinceMousedown) {
          disabled = !disabled;
          dragBar.classed('disabled', disabled);
          return dispatch.change(loopLeft, loopRight, disabled);
        }
      };
      dragstartTime = null;
      dragstart = function() {
        movedSinceMousedown = false;
        stopPropagation();
        dragstartTime = xPosition(this);
        if (!dragBar) {
          return drawDragBar();
        }
      };
      dragmove = function() {
        var position;
        if (!movedSinceMousedown) {
          movedSinceMousedown = true;
          loopLeft = loopRight = dragstartTime;
        }
        if (disabled) {
          disabled = false;
          dragBar.classed('disabled', disabled);
        }
        position = xPosition(this);
        loopRight = position;
        updateDragBar();
        return dispatch.changing(loopLeft, loopRight, disabled);
      };
      dragend = function() {
        return dispatch.change(loopLeft, loopRight, disabled);
      };
      drag = d3.behavior.drag().on('dragstart', dragstart).on('drag', dragmove).on('dragend', dragend);
      dragDelta = function() {
        return x.invert(d3.event.dx) - x.invert(0);
      };
      dragstartOnDragBar = function() {
        if (!disabled) {
          return stopPropagation();
        }
      };
      dragendOnDragBar = function() {
        stopPropagation();
        return dispatch.change(loopLeft, loopRight, disabled);
      };
      barDrag = d3.behavior.drag().on('dragstart', dragstartOnDragBar).on('dragend', dragendOnDragBar).on('drag', function() {
        var delta;
        movedSinceMousedown = true;
        stopPropagation();
        delta = dragDelta();
        loopLeft += delta;
        loopRight += delta;
        updateDragBar();
        return dispatch.changing(loopLeft, loopRight, disabled);
      });
      barEndDrag = d3.behavior.drag().on('dragstart', dragstartOnDragBar).on('dragend', dragendOnDragBar).on('drag', function() {
        movedSinceMousedown = true;
        stopPropagation();
        loopRight = Math.max(loopRight + dragDelta(), loopLeft);
        updateDragBar();
        return dispatch.changing(loopLeft, loopRight, disabled);
      });
      barStartDrag = d3.behavior.drag().on('dragstart', dragstartOnDragBar).on('dragend', dragendOnDragBar).on('drag', function() {
        movedSinceMousedown = true;
        stopPropagation();
        loopLeft = Math.min(loopLeft + dragDelta(), loopRight);
        updateDragBar();
        return dispatch.changing(loopLeft, loopRight, disabled);
      });
      selection.append('rect').attr('class', 'loopSelector').attr('x', 0).attr('y', -20).attr('width', width).attr('height', '20');
      loopSelector.timeline().on('change', function() {
        if (dragBar) {
          return updateDragBar();
        }
      });
      selection.call(drag);
      if (loopLeft !== null && loopRight !== null) {
        return drawDragBar();
      }
    };
    loopSelector = function(_selection) {
      selection = _selection;
      return draw(_selection);
    };
    loopSelector.domain = function(domain) {
      if (!arguments.length) {
        return [loopLeft, loopRight];
      }
      loopLeft = domain[0], loopRight = domain[1];
      if (selection && (!dragBar)) {
        draw(selection);
        dispatch.change(loopLeft, loopRight, disabled);
      }
      updateDragBar();
      return loopSelector;
    };
    loopSelector.on = function(type, listener) {
      dispatch.on(type, listener);
      return loopSelector;
    };
    loopSelector.disabled = function(_disabled) {
      if (!arguments.length) {
        return disabled;
      }
      disabled = _disabled;
      if (dragBar) {
        dragBar.classed('disabled', disabled);
      }
      return loopSelector;
    };
    return loopSelector = d3.rebind(loopSelector, commonProperties(), 'timeline');
  };

}).call(this);

},{"../commonProperties":6,"d3-prong":46}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var d3, pot, slider;

  d3 = require('d3-prong');

  slider = require('./slider');

  pot = require('./pot');

  module.exports = function() {
    var height, margin, mixer, panPot, sequence, volumeSlider, width;
    sequence = null;
    volumeSlider = slider().domain([0, 100]).height(100).width(40).format(d3.format('f')).key('volume').horizontal(false).circleStyle(true);
    panPot = pot().domain([-64, +63]).radius(20).key('pan').format(d3.format('d'));
    margin = {
      top: 40,
      right: 40,
      bottom: 40,
      left: 40
    };
    width = 1200 - margin.left - margin.right;
    height = 250 - margin.bottom - margin.top;
    mixer = function(selection) {
      var draw, svg, tracks;
      tracks = sequence.tracks().filter(function(track) {
        var ref;
        return (ref = track.type) === 'audio' || ref === 'audioRegions';
      });
      svg = selection.append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      draw = function() {
        var strips;
        svg.selectAll('g').remove();
        strips = svg.selectAll('g').data(tracks).enter().append('g').attr('transform', function(d, i) {
          return 'translate(' + (i * 75) + ',0)';
        }).on('mouseover', function(d) {
          d3.select(this).classed('over', true);
          return d.over = true;
        }).on('mouseout', function(d) {
          d3.select(this).classed('over', false);
          return d.over = false;
        }).each(function(d) {
          var thiz;
          thiz = d3.select(this);
          return d.watch('over', function() {
            return thiz.classed('over', d.over);
          });
        });
        strips.append('g').call(panPot);
        strips.append('g').attr('transform', 'translate(-20,50)').call(volumeSlider);
        return strips.append('text').attr('transform', 'translate(0, 190)').attr('text-anchor', 'middle').text(prong.trackName);
      };
      draw();
      return mixer.loadPreset = function(preset, duration) {
        var j, len, setting, track;
        for (j = 0, len = tracks.length; j < len; j++) {
          track = tracks[j];
          setting = null;
          if (track.id in preset.settings) {
            setting = preset.settings[track.id];
          } else if ('_default' in preset.settings) {
            setting = preset.settings['_default'];
          }
          if (!setting) {
            continue;
          }
          if ('volume' in setting) {
            track._startVolume = track.volume;
            track._deltaVolume = setting.volume - track.volume;
          }
          if ('pan' in setting) {
            track._targetPan = setting.pan;
            track._deltaPan = setting.pan - track.pan;
          }
        }
        return d3.timer(function(elapsed) {
          var k, len1, position;
          position = elapsed / duration;
          if (position > 1) {
            position = 1;
          }
          for (k = 0, len1 = tracks.length; k < len1; k++) {
            track = tracks[k];
            if ('_deltaVolume' in track) {
              track.volume = track._startVolume + (track._deltaVolume * position);
            }
            if ('_deltaPan' in track) {
              track.pan = track._startPan + (track._deltaPan * position);
            }
          }
          return position === 1;
        });
      };
    };
    mixer.sequence = function(_sequence) {
      if (!arguments.length) {
        return sequence;
      }
      sequence = _sequence;
      return mixer;
    };
    return mixer;
  };

}).call(this);

},{"./pot":18,"./slider":20,"d3-prong":46}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var commonProperties, d3, uid;

  commonProperties = require('../commonProperties');

  uid = require('../uid');

  d3 = require('d3-prong');

  module.exports = function() {
    var getTicks, musicalTime, musicalTimeline, selection, updateMinorLines;
    musicalTime = null;
    selection = null;
    updateMinorLines = function(x) {
      var minorLines, ticks;
      ticks = getTicks();
      minorLines = selection.selectAll('line.minor').data(ticks, function(d) {
        return d;
      });
      minorLines.attr('x1', x).attr('x2', x);
      minorLines.enter().append('line').attr('class', 'minor').attr('y1', 0).attr('y2', 10).attr('x1', x).attr('x2', x);
      return minorLines.exit().remove();
    };
    getTicks = function() {
      var ticks;
      ticks = [];
      musicalTime.bars.forEach(function(chunk) {
        return ticks = ticks.concat(d3.range(chunk.startBarNumber, chunk.startBarNumber + chunk.numberOfBars, 1 / chunk.numerator));
      });
      return ticks;
    };
    musicalTimeline = function(_selection) {
      var _uid, axis, getX, redraw, tickFormat, ticks, timeline, x;
      selection = _selection;
      selection.classed('musicalTimeline', true);
      timeline = musicalTimeline.timeline();
      getX = function() {
        return musicalTime.barsToPixels(timeline.x());
      };
      x = getX();
      ticks = d3.range(1, musicalTime.finalBarNumber + 2);
      tickFormat = function(tick) {
        if (tick < musicalTime.finalBarNumber + 1) {
          return d3.format('n')(tick);
        }
        return '';
      };
      axis = d3.svg.axis().scale(x).tickSize(10, 5, 0).tickValues(ticks).tickFormat(tickFormat);
      updateMinorLines(x, selection);
      selection.attr('width', timeline.width()).call(axis).style('cursor', 'pointer').on('click', function() {
        var endTime, sequence, startTime;
        sequence = musicalTimeline.timeline().sequence();
        startTime = musicalTime.bars[0].startTime;
        endTime = musicalTime.endTime;
        return sequence.play(startTime, endTime, true);
      });
      redraw = function() {
        x = getX();
        updateMinorLines(x);
        return selection.call(axis.scale(x));
      };
      _uid = uid();
      timeline.on('change.musicalTimeline' + _uid, function() {
        return redraw();
      });
      musicalTimeline.destroy = function() {
        return timeline.on('change.musicalTimeline' + _uid, null);
      };
      return musicalTimeline;
    };
    musicalTimeline.musicalTime = function(_musicalTime) {
      if (!arguments.length) {
        return musicalTime;
      }
      musicalTime = _musicalTime;
      return musicalTimeline;
    };
    return d3.rebind(musicalTimeline, commonProperties(), 'timeline');
    return musicalTimeline;
  };

}).call(this);

},{"../commonProperties":6,"../uid":42,"d3-prong":46}],15:[function(require,module,exports){
// this is the visual component which is used to draw the note onset lines
var commonProperties = require('../commonProperties'),
	uid = require('../uid');

module.exports = function(){
    //var times;

    var onsets = function(){
        var selection = this,
            startOffset = 0;

        function draw(){

            selection.each(function(d){

                var sel = d3.select(this),
                    x = onsets.x(),
                    width = onsets.width(),
                    height = onsets.height() || 128,
                    domain = x.domain(),
                    range = x.range(),
                    startOffset = d.startTime || 0;
                    
                    onsetTimes = sel.datum().onsetTimes || [];

                x = d3.scale.linear().range(range).domain([domain[0] - startOffset, domain[1] - startOffset])

                var startTime = Math.max(x.domain()[0],0);
                
                var visibleOnsetTimes = onsetTimes.filter(function(time){
                        return time > startTime && time < domain[1];
                    })

                    sel.selectAll('.onset').remove()
                    // now draw the new ones
                    sel.selectAll('.onset')
                        .data(visibleOnsetTimes)
                        .enter()
                        .append('rect')
                        .attr('class','onset')
                        .attr('x', function(d){
                            //return x(d + track.startTime);
                            return x(d)
                        })
                        .attr('width',1)
                        .attr('y', 0)
                        .attr('height', 128)
            });
        }

        draw();

        var timeline = onsets.timeline();

        if (timeline){
            // this timing logic tries to keep waveform redrawing as smooth
            // as possible. It times how long it takes to redraw the waveform
            // and makes sure not to redraw more frequently than that

            var lastTimeout = null,
                drawingTime = null,
                lastDrawingStart = null;

            function drawAndTime(){
                var start = new Date();
                draw();
                drawingTime = new Date() - start;
            }

            timeline.on('change.' + uid(), function(){
                if (lastTimeout) clearTimeout(lastTimeout);
                if (!lastDrawingStart || (new Date() - lastDrawingStart) > (drawingTime * 2)){
                    drawAndTime();
                }else{
                    lastTimeout = setTimeout(function(){
                        drawAndTime();
                        lastTimeout = null;
                    }, 50);  
                }    
            })
        }
    }

    // inherit properties from the commonProperties
    return d3.rebind(onsets, commonProperties(), 'x', 'width', 'height', 'timeline');
}
},{"../commonProperties":6,"../uid":42}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var d3;

  d3 = require('d3-prong');

  module.exports = function() {
    var decimalPlaces, dispatch, drawbarData, drawbars, height, ignorePhase, magnitudeSlider, makeSlider, organController, phaseSlider, selection, sliderChangeHandler, width;
    drawbars = 33;
    decimalPlaces = 3;
    width = 600;
    height = 400;
    dispatch = d3.dispatch('change');
    drawbarData = d3.range(drawbars).map(function(i) {
      return {
        magnitude: 0,
        phase: 0
      };
    });
    selection = null;
    ignorePhase = false;
    makeSlider = function(key) {};
    magnitudeSlider = prong.slider().domain([0, 1]).height(height / 3 * 2 - 5).key('magnitude').exponent(0.2).format(d3.format('.3f'));
    phaseSlider = prong.slider().domain([-Math.PI, Math.PI]).height(height / 3 - 5).key('phase').format(d3.format('.2f'));
    sliderChangeHandler = function() {
      return dispatch.change(organController.frequencyComponents());
    };
    magnitudeSlider.on('change', sliderChangeHandler);
    phaseSlider.on('change', sliderChangeHandler);
    organController = function(_selection) {
      var g, widthPerDrawbar;
      if (_selection) {
        selection = _selection;
      }
      widthPerDrawbar = width / drawbars;
      magnitudeSlider.width(widthPerDrawbar - 1);
      phaseSlider.width(widthPerDrawbar - 1);
      g = selection.selectAll('g').data(drawbarData).enter().append('g').attr('transform', function(d, i) {
        return "translate(" + (i * widthPerDrawbar + 2) + ",10)";
      }).classed('black', function(d, i) {
        if (i === 0) {
          return true;
        }
        while (i > 1) {
          i = i / 2.0;
        }
        return Math.round(i) !== i;
      });
      g.append('g').call(magnitudeSlider);
      return g.append('g').attr('transform', "translate(0," + (height * 2 / 3) + ")").call(phaseSlider);
    };
    organController.frequencyComponents = function(components) {
      var _imag, _real, imag, real;
      if (!arguments.length) {
        if (ignorePhase) {
          real = drawbarData.map(function(d) {
            return d.magnitude;
          });
          imag = real.map(function(d) {
            return 0;
          });
        } else {
          real = drawbarData.map(function(d) {
            return Math.cos(d.phase) * d.magnitude;
          });
          imag = drawbarData.map(function(d) {
            return Math.sin(d.phase) * d.magnitude;
          });
        }
        return [real, imag];
      }
      _real = components[0], _imag = components[1];
      if (_real.length !== _imag.length) {
        throw new Exception('Must have the same number of real and imaginary components');
      }
      drawbarData = _real.map(function(_, i) {
        var magnitude, phase;
        real = _real[i];
        imag = _imag[i];
        magnitude = Math.sqrt(real * real + imag * imag);
        phase = Math.atan2(imag, real);
        return {
          magnitude: magnitude,
          phase: phase
        };
      });
      drawbars = drawbarData.length;
      if (selection) {
        selection.html('');
        organController();
      }
      sliderChangeHandler();
      return this;
    };
    organController.drawbarData = function(_drawbarData) {
      if (!arguments.length) {
        return drawbarData;
      }
      drawbarData = _drawbarData;
      drawbars = drawbarData.length;
      sliderChangeHandler();
      return organController;
    };
    organController.width = function(_width) {
      if (!arguments.length) {
        return width;
      }
      width = _width;
      return organController;
    };
    organController.height = function(_height) {
      if (!arguments.length) {
        return height;
      }
      height = _height;
      magnitudeSlider.height(height / 3 * 2 - 5);
      phaseSlider.height(height / 3 - 5);
      return organController;
    };
    organController.on = function(type, listener) {
      dispatch.on(type, listener);
      return organController;
    };
    organController.ignorePhase = function(_ignorePhase) {
      if (!arguments.length) {
        return ignorePhase;
      }
      ignorePhase = _ignorePhase;
      return sliderChangeHandler();
    };
    return organController;
  };

}).call(this);

},{"d3-prong":46}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var d3;

  d3 = require('d3-prong');

  module.exports = function() {
    var dispatch, height, playStopButton, playing, width;
    width = 50;
    height = width;
    playing = false;
    dispatch = d3.dispatch('change');
    playStopButton = function(selection) {
      var button, g, left, play, setDisplay, squareRadius, stop, svg, top, triangleRadius;
      svg = selection.append('svg').attr('class', 'playStopButton').attr('height', height).attr('width', width);
      g = svg.append('g').attr('transform', "translate(" + (width / 2) + "," + (height / 2) + ")");
      button = g.append('circle').attr('cx', 0).attr('cy', 0).attr('r', width / 2);
      triangleRadius = width / 3;
      top = triangleRadius * Math.sin(Math.PI * 2 / 3);
      left = triangleRadius * Math.cos(Math.PI * 2 / 3);
      play = g.append('polygon').attr('points', triangleRadius + ",0 " + left + "," + top + " " + left + "," + (0 - top));
      squareRadius = width / 4;
      stop = g.append('rect').attr('x', 0 - squareRadius + 'px').attr('y', 0 - squareRadius + 'px').attr('width', squareRadius * 2).attr('height', squareRadius * 2).style('display', 'none');
      setDisplay = function() {
        play.style('display', playing ? 'none' : 'block');
        return stop.style('display', playing ? 'block' : 'none');
      };
      g.on('click', function() {
        playing = !playing;
        setDisplay();
        return dispatch.change(playing);
      });
      return playStopButton.playing = function(_playing) {
        if (!arguments.length) {
          return playing;
        }
        playing = _playing;
        setDisplay();
        return playStopButton;
      };
    };
    playStopButton.on = function(type, listener) {
      dispatch.on(type, listener);
      return playStopButton;
    };
    return playStopButton;
  };

}).call(this);

},{"d3-prong":46}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var d3;

  d3 = require('d3-prong');

  module.exports = function() {
    var angle, dispatch, dragging, format, key, pot, prefix, radius, scale, title;
    dragging = false;
    radius = 20;
    angle = Math.PI * 0.65;
    scale = d3.scale.linear().range([-angle, angle]).clamp(true);
    format = d3.format('f');
    dispatch = d3.dispatch('change', 'end');
    prefix = '';
    title = '';
    key = null;
    pot = function(selection) {
      var arc, backgroundArc, drag, dragend, dragmove, dragstart, redraw, setupEvents;
      dragstart = function() {
        selection.classed('dragging', true);
        dragging = true;
        return d3.event.sourceEvent.stopPropagation();
      };
      dragend = function() {
        selection.classed('dragging', false);
        dragging = false;
        return d3.event.sourceEvent.stopPropagation();
      };
      dragmove = function(d, i) {
        var max, min;
        d[key] -= d3.event.dy;
        min = scale.domain()[0];
        max = scale.domain()[1];
        if (d[key] > max) {
          d[key] = max;
        }
        if (d[key] < min) {
          d[key] = min;
        }
        redraw();
        return dispatch.change(d, i, key);
      };
      selection.attr('class', 'pot');
      drag = d3.behavior.drag().on('dragstart', dragstart).on('drag', dragmove).on('dragend', dragend);
      backgroundArc = d3.svg.arc().outerRadius(radius + 12).innerRadius(radius).startAngle(-angle).endAngle(angle);
      arc = d3.svg.arc().outerRadius(radius + 12).innerRadius(radius).startAngle(function(d) {
        var value;
        value = d[key];
        return scale(value < 0 ? value : 0);
      }).endAngle(function(d) {
        var value;
        value = d[key];
        return scale(value > 0 ? value : 0);
      });
      setupEvents = function(selection) {
        return selection.call(drag).on('dblclick', function(d) {
          d[key] = 0;
          return redraw();
        });
      };
      selection.call(setupEvents);
      selection.append('circle').attr('r', radius);
      selection.append('path').attr('class', 'background').attr('d', backgroundArc);
      selection.append('path').attr('class', 'arc pan').attr('d', arc);
      selection.append('text').attr('text-anchor', 'middle').attr('transform', "translate(0," + (radius / 4) + ")").text(function(d) {
        return d[key];
      });
      selection.each(function(d) {
        return d.watch(key, function() {
          return redraw(d);
        });
      });
      return redraw = function(d) {
        selection.selectAll('.arc').attr('d', arc);
        return selection.selectAll('text').text(function(d) {
          return d[key];
        });
      };
    };
    pot.domain = function(_domain) {
      if (!arguments.length) {
        return scale.domain();
      }
      scale.domain(_domain);
      return pot;
    };
    pot.radius = function(_radius) {
      if (!arguments.length) {
        return radius;
      }
      radius = _radius;
      return pot;
    };
    pot.format = function(_format) {
      if (!arguments.length) {
        return format;
      }
      format = _format;
      return pot;
    };
    pot.on = function(type, listener) {
      dispatch.on(type, listener);
      return pot;
    };
    pot.key = function(_key) {
      if (!arguments.length) {
        return key;
      }
      key = _key;
      return pot;
    };
    return pot;
  };

}).call(this);

},{"d3-prong":46}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2

/*
this module does all the preparation of data for rendering waveforms. In the
general case, an arbitrary clip of a buffer can be rendered to a visible
domain. Part of the clip may be obscured, and the clip may have zero in
a different place from the main timeline. The pcm data is also downsampled
to be rendered as quickly as possible.

timeline

 5    6    7    8    9    10 <- Main timeline
 |    |    |    |    |    |
 |------------------------|
 |         2    3    4    |   6 <- Time into wave
 |          ___________________
 |         |                  |
 |          -------------------
 |                        |
 --------------------------

In this example, the clip is defined from seconds 2 to 6 of the buffer,
but is visible from 2 to 5. There are 50 pixels per second. So, the two
part return value will be

data - a 200 element array, giving 50 pixels per second which is seconds
2 - 5 of the audio downsampled

scale - a scale which maps the index within the data array to the pixels
inside the viewable area. In this case it is

0 -> 100
1 -> 101
2 -> 102

In the general case, the downsampling might not be exactly 1 per pixel,
because it is quicker and easier to take the cache data which is closest
to the zoom level, so the indexes may map to fractional pixels.

The parameters passed are

@d - an object which must contain various keys. These include
    d._buffer - the buffer object containing the audio. The only properties
        use are d._buffer.sampleRate and optionally d._buffer.sampleOffset
    d._channel - the channel in the buffer to be rendered
    d.startTime - optional. The point in the main timeline where the clip starts
        in the above example d.startTime == 7. Defaults to 0
    d.clipStart - optional. If given, is the time into the audio file
        where the clip starts. In the above example, d.clipStart == 2. Defaults to 0
    d.clipEnd - optional. The time into the audio file where the clip ends.
        In the above example d.clipEnd == 6

@x - the x scale of the viewable area. The domain will be used to determine
    the viewable area (in seconds) and the range will be used to determine
    the pixels per second, and so the downsampling ratio that needs to be used.
    In the above example x.domain() == [5, 10] and x.range() == [0, 250]

the @return value is [data, scale] as described above

See pcmRendering.spec.coffee for more examples
 */

(function() {
  var d3, domainWidth, downsampleCache;

  downsampleCache = require('../analysis/downsampleCache');

  d3 = require('d3-prong');

  domainWidth = function(domain) {
    return domain[1] - domain[0];
  };

  module.exports = function(d, x) {
    var buffer, cacheObject, channel, clipEnd, clipOffset, clipStart, data, length, pixelWidth, ref, sampleOffset, sampleX, samplesPerPixel, startTime, viewEnd, viewStart, visibleDomain;
    if (d._clip) {
      channel = d._clip._channel;
      buffer = d._clip._buffer;
    } else {
      channel = d._channel;
      buffer = d._buffer;
    }
    sampleOffset = buffer.sampleOffset || 0;
    startTime = d.startTime || 0;
    clipStart = d.clipStart || 0;
    clipEnd = d.clipEnd || channel.length / buffer.sampleRate;
    visibleDomain = x.domain();
    length = clipEnd - clipStart;
    viewStart = clipStart + Math.max(visibleDomain[0] - startTime, 0);
    viewEnd = clipEnd - Math.max(startTime + length - visibleDomain[1], 0);
    if (viewStart > viewEnd) {
      return [null, null];
    }
    clipOffset = startTime - clipStart;
    pixelWidth = domainWidth(x.range()) * (viewEnd - viewStart) / domainWidth(visibleDomain);
    cacheObject = d._clip || d;
    ref = downsampleCache(cacheObject, [viewStart, viewEnd], pixelWidth), data = ref[0], samplesPerPixel = ref[1];
    sampleX = d3.scale.linear().domain([0, data.length]).range([x(viewStart + clipOffset), x(viewEnd + clipOffset)]);
    return [data, sampleX, samplesPerPixel];
  };

}).call(this);

},{"../analysis/downsampleCache":3,"d3-prong":46}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var d3;

  d3 = require('d3-prong');

  module.exports = function() {
    var circleStyle, dispatch, dragend, dragging, dragstart, format, height, horizontal, key, padding, prefix, scale, slider, title, value, width;
    dragging = false;
    width = 40;
    height = 100;
    horizontal = false;
    scale = d3.scale.pow().exponent(1).range([0, height]).clamp(true);
    format = d3.format('.2f');
    dispatch = d3.dispatch('change');
    prefix = '';
    title = '';
    key = null;
    padding = 1;
    value = null;
    circleStyle = false;
    dragstart = function(e) {
      dragging = true;
      return d3.event.sourceEvent.stopPropagation();
    };
    dragend = function(e) {
      dragging = false;
      return d3.event.sourceEvent.stopPropagation();
    };
    slider = function(selection) {
      var background, backgroundLength, circle, cy, drag, draggerDisplay, dragmove, g, getText, position, redraw, rounding, text, verticalBackgroundY, verticalTextY;
      getText = function(d) {
        if (key) {
          return prefix + format(d[key]);
        } else {
          return prefix + format(value);
        }
      };
      dragmove = function(d, i) {
        var _value, last;
        if (!dragging) {
          return;
        }
        _value = scale.invert(horizontal ? d3.event.x : d3.event.y);
        last = key ? d[key] : value;
        if (last === _value) {
          return;
        }
        if (key) {
          d[key] = _value;
        } else {
          value = _value;
        }
        text.text(getText(d));
        redraw();
        if (key) {
          dispatch.change(d, i, key);
        } else {
          dispatch.change(value);
        }
        return d3.event.sourceEvent.stopPropagation();
      };
      g = selection;
      g.classed('slider', true);
      drag = d3.behavior.drag().on('dragstart', dragstart).on('drag', dragmove).on('dragend', dragend);
      circle = null;
      text = null;
      background = null;
      height = Math.abs(scale.range()[0] - scale.range()[1]);
      position = function(d) {
        if (key) {
          return scale(d[key]);
        } else {
          return scale(value);
        }
      };
      cy = function(d) {
        return position(d) + 1;
      };
      backgroundLength = function(d) {
        if (horizontal) {
          return position(d) + circleStyle * width + 1;
        } else {
          return Math.abs(scale(0) - position(d)) + circleStyle * (width - padding * 2);
        }
      };
      verticalBackgroundY = function(d) {
        var p;
        p = Math.min(position(d), scale(0));
        return p - (circleStyle * width / 2) + 1;
      };
      verticalTextY = function(d) {
        return position(d) + 3;
      };
      rounding = function(selection) {
        if (circleStyle) {
          return selection.attr('rx', width / 2).attr('ry', width / 2);
        }
      };
      draggerDisplay = function(selection) {
        if (!circleStyle) {
          return selection.style('opacity', '0');
        }
      };
      if (horizontal) {
        g.append('rect').attr('y', 0).attr('x', scale.range()[0] - circleStyle * width / 2).attr('height', width).attr('width', height + circleStyle * width).call(rounding);
        background = g.append('rect').attr('class', 'background').attr('x', 0 - circleStyle * width / 2).attr('y', padding).attr('height', width - padding * 2).attr('width', function(d) {
          return backgroundLength(d) - 1;
        }).call(rounding);
        circle = g.append('circle').attr('cy', width / 2).attr('cx', function(d) {
          return position(d) - 1;
        }).attr('r', width / 2).style('cursor', 'pointer').attr('fill', 'white').call(drag).call(draggerDisplay);
        text = g.append('text').attr('x', function(d) {
          return position(d) - 1;
        }).attr('y', width / 2 + 2).attr('text-anchor', 'middle').attr('alignment-baseline', 'middle').attr('cursor', 'pointer').text(getText).call(drag);
      } else {
        g.append('rect').attr('x', 0).attr('y', scale.range()[1] - circleStyle * width / 2).attr('height', height + circleStyle * width).attr('width', width).call(rounding);
        background = g.append('rect').attr('class', 'background').attr('x', padding).attr('y', verticalBackgroundY).attr('height', backgroundLength).attr('width', width - padding * 2).call(rounding);
        circle = g.append('circle').attr('cx', width / 2).attr('cy', cy).attr('r', width / 2).style('cursor', 'pointer').attr('fill', 'white').call(drag).call(draggerDisplay);
        text = g.append('text').attr('x', width / 2).attr('y', verticalTextY).attr('text-anchor', 'middle').attr('alignment-baseline', 'middle').attr('cursor', 'pointer').text(getText).call(drag);
      }
      if (key) {
        selection.each(function(d) {
          return d.watch(key, function() {
            return redraw(d);
          });
        });
      }
      return redraw = function(d) {
        if (horizontal) {
          circle.attr('cx', function(d) {
            return position(d) - 1;
          });
          text.attr('x', function(d) {
            return position(d) - 1;
          }).text(getText);
          return background.attr('width', function(d) {
            return backgroundLength(d) - 1;
          });
        } else {
          circle.attr('cy', cy);
          text.attr('y', verticalTextY).text(getText);
          return background.attr('y', verticalBackgroundY).attr('height', backgroundLength);
        }
      };
    };
    slider.domain = function(_domain) {
      if (!arguments.length) {
        return scale.domain();
      }
      scale.domain(_domain);
      return slider;
    };
    slider.exponent = function(_exponent) {
      if (!arguments.length) {
        return scale.exponent();
      }
      scale.exponent(_exponent);
      return slider;
    };
    slider.height = function(_height) {
      if (!arguments.length) {
        return height;
      }
      height = _height;
      if (horizontal) {
        scale.range([0, height]);
      } else {
        scale.range([height, 0]);
      }
      return slider;
    };
    slider.width = function(_width) {
      if (!arguments.length) {
        return width;
      }
      width = _width;
      return slider;
    };
    slider.format = function(_format) {
      if (!arguments.length) {
        return format;
      }
      format = _format;
      return slider;
    };
    slider.prefix = function(_prefix) {
      if (!arguments.length) {
        return prefix;
      }
      prefix = _prefix;
      return slider;
    };
    slider.horizontal = function(_horizontal) {
      var range;
      if (!arguments.length) {
        return horizontal;
      }
      if (_horizontal && !horizontal) {
        range = scale.range();
        scale.range([range[1], range[0]]);
      }
      horizontal = _horizontal;
      return slider;
    };
    slider.on = function(type, listener) {
      dispatch.on(type, listener);
      return slider;
    };
    slider.key = function(_key) {
      if (!arguments.length) {
        return key;
      }
      key = _key;
      return slider;
    };
    slider.title = function(_title) {
      if (!arguments.length) {
        return title;
      }
      title = _title;
      return slider;
    };
    slider.value = function(_value) {
      if (!arguments.length) {
        return value;
      }
      value = _value;
      return slider;
    };
    slider.circleStyle = function(_circleStyle) {
      if (!arguments.length) {
        return circleStyle;
      }
      circleStyle = _circleStyle;
      return slider;
    };
    return slider;
  };

}).call(this);

},{"d3-prong":46}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var FFT, commonProperties, d3, uid;

  commonProperties = require('../commonProperties');

  FFT = require('fft');

  uid = require('../uid');

  d3 = require('d3-prong');

  module.exports = function() {
    var n, spectrogram;
    n = 1024;
    spectrogram = function() {
      var draw, selection, timeline;
      selection = this;
      draw = function() {
        var height, width, x;
        x = spectrogram.x();
        width = spectrogram.width();
        height = spectrogram.height();
        return selection.each(function(d) {
          var alpha, buffer, canvas, centreOfGravity, data, domain, drawContext, fft, frequencyHeight, i, input, j, k, l, lightness, m, max, maxPosition, mean, o, output, overallEndSample, overallStartSample, pixelHeight, realOutput, ref, ref1, ref2, results, significants, startSample, time, totalMoment, totalWeight, value, y;
          data = d._channel;
          buffer = d._buffer;
          canvas = d3.select(this);
          drawContext = canvas.node().getContext('2d');
          fft = new FFT.complex(n, false);
          output = new Float32Array(n * 2);
          lightness = d3.scale.log().range([100, 0]).domain([1, 480]);
          alpha = d3.scale.log().range([0, 1]).domain([1, 480]);
          frequencyHeight = n / 12;
          y = d3.scale.linear().range([height, 0]).domain([0, frequencyHeight / 2]);
          pixelHeight = height / frequencyHeight;
          this.width = this.width;
          domain = x.domain();
          overallStartSample = Math.max(Math.round(domain[0] * buffer.sampleRate) - 1, 0);
          overallEndSample = Math.round(domain[1] * buffer.sampleRate) - 1;
          data = data.subarray(overallStartSample, overallEndSample + n);
          if (domain[1] > buffer.duration) {
            width = x(buffer.duration);
          }
          results = [];
          for (i = k = 0, ref = width; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            startSample = ~~((data.length - n) / width * i);
            input = data.subarray(startSample, startSample + n);
            fft.simple(output, input, 'real');
            realOutput = new Float32Array(Math.round(frequencyHeight));
            for (j = m = 0, ref1 = frequencyHeight; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
              realOutput[j] = Math.sqrt(output[j * 2] * output[j * 2] + output[j * 2 + 1] * output[j * 2 + 1]);
            }
            mean = d3.mean(realOutput);
            max = 0;
            maxPosition = null;
            time = (overallStartSample + startSample) / buffer.sampleRate;
            for (j = o = 0, ref2 = frequencyHeight; 0 <= ref2 ? o < ref2 : o > ref2; j = 0 <= ref2 ? ++o : --o) {
              value = realOutput[j];
              if (value > max) {
                max = value;
                maxPosition = j;
              }
              l = value > 80 ? 100 : lightness(value);
              drawContext.fillStyle = "hsla(1, 100%, " + l + "%, " + (alpha(value)) + ")";
              drawContext.fillRect(i, y(j), 1, pixelHeight * 2);
            }
            significants = realOutput.map(function(d) {
              if (d > 50) {
                return d;
              } else {
                return 0;
              }
            });
            totalMoment = d3.sum(significants, function(d, i) {
              return d * i;
            });
            totalWeight = d3.sum(significants);
            centreOfGravity = totalMoment / totalWeight;
            if (max > 50) {
              drawContext.fillStyle = 'hsla(120, 100%, 50%, 1)';
              results.push(drawContext.fillRect(i, y(centreOfGravity), 10, 2));
            } else {
              results.push(void 0);
            }
          }
          return results;
        });
      };
      draw();
      timeline = spectrogram.timeline();
      if (timeline) {
        return timeline.on('end', draw);
      }
    };
    return d3.rebind(spectrogram, commonProperties(), 'x', 'height', 'width', 'timeline');
  };

}).call(this);

},{"../commonProperties":6,"../uid":42,"d3-prong":46,"fft":47}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var History, LoopSelector, commonProperties, d3, prong;

  commonProperties = require('../commonProperties');

  d3 = require('d3-prong');

  LoopSelector = require('./loopSelector');

  History = require('../history/history');

  prong = require('../');

  module.exports = function() {
    var axis, canSelectLoop, createHistory, dispatch, formatSeconds, history, historyCodec, loopDisabled, loopDomain, loopSelector, mouseWheel, notBelowZero, numberOfTicks, round, scrollFinished, scrollTimeoutId, scrollZone, secondsFormatter, selection, setSecondsFormatter, timeline, updateMinorLines, zoomable;
    dispatch = d3.dispatch('change', 'end', 'timeselect', 'loopChange', 'loopChanging');
    selection = null;
    axis = null;
    secondsFormatter = null;
    scrollZone = null;
    zoomable = true;
    canSelectLoop = false;
    loopSelector = null;
    history = null;
    loopDomain = [null, null];
    loopDisabled = false;
    setSecondsFormatter = function() {
      var ticks;
      ticks = numberOfTicks();
      return secondsFormatter = timeline.x().tickFormat(ticks);
    };
    formatSeconds = function(seconds) {
      var minutes;
      if (seconds >= 60) {
        minutes = Math.floor(seconds / 60);
        seconds = seconds % 60;
        return minutes + ':' + (seconds < 10 ? '0' : '') + secondsFormatter(seconds);
      } else {
        return secondsFormatter(seconds);
      }
    };
    scrollTimeoutId = null;
    scrollFinished = function() {
      scrollTimeoutId = null;
      return dispatch.end();
    };
    notBelowZero = function(domain) {
      if (domain[0] < 0) {
        domain[1] -= domain[0];
        domain[0] = 0;
      }
      return domain;
    };
    numberOfTicks = function() {
      var divider, pixelsPerSecond, ticks, width, x;
      x = timeline.x();
      width = Math.abs(x.range()[1] - x.range()[0]);
      pixelsPerSecond = x(1) - x(0);
      divider = 50;
      if (x.domain()[0] > 60) {
        divider += 20;
      }
      if (pixelsPerSecond > 120) {
        divider += 20;
      }
      ticks = Math.round(width / divider);
      axis.ticks(ticks);
      return ticks;
    };
    mouseWheel = function() {
      var after, before, delta, deltaTime, domain, downDomain, downTime, lhs, newDomain, pointer, rhs, x, zoomFactor;
      if (!d3.event.wheelDeltaX) {
        return;
      }
      if (Math.abs(d3.event.wheelDeltaX) > Math.abs(d3.event.wheelDeltaY)) {
        d3.event.preventDefault();
        d3.event.stopPropagation();
      }
      delta = d3.event.wheelDeltaX / 12;
      x = timeline.x();
      if (d3.event.altKey) {
        if (!zoomable) {
          return;
        }
        pointer = d3.mouse(selection.node());
        downTime = x.invert(pointer[0]);
        downDomain = x.domain();
        lhs = downTime - downDomain[0];
        rhs = downDomain[1] - downTime;
        zoomFactor = Math.pow(2, delta / 1200);
        newDomain = [downTime - (lhs / zoomFactor), downTime + (rhs / zoomFactor)];
        newDomain = notBelowZero(newDomain);
        timeline.domain(newDomain);
        return;
      }
      deltaTime = x.invert(0) - x.invert(delta);
      before = x(0);
      domain = x.domain();
      domain[0] += deltaTime;
      domain[1] += deltaTime;
      domain = notBelowZero(domain);
      x.domain(domain);
      after = x(0);
      timeline.x(x).redraw();
      if (scrollTimeoutId !== null) {
        window.clearTimeout(scrollTimeoutId);
      }
      scrollTimeoutId = window.setTimeout(scrollFinished, 200);
      return dispatch.change(x);
    };
    updateMinorLines = function(x) {
      var minorLines, ticks;
      ticks = numberOfTicks();
      minorLines = selection.selectAll('line.minor').data(x.ticks(ticks * 5), function(d) {
        return d;
      });
      minorLines.attr('x1', x).attr('x2', x);
      minorLines.enter().append('line').attr('class', 'minor').attr('y1', 0).attr('y2', 5).attr('x1', x).attr('x2', x);
      return minorLines.exit().remove();
    };
    round = function(d) {
      return d3.round(d, 6);
    };
    historyCodec = {
      stringify: function() {
        var domain;
        domain = timeline.x().domain().map(round);
        loopDomain = timeline.loop().map(round);
        loopDisabled = timeline.loopDisabled();
        return domain + ";" + loopDomain + ";" + (loopDisabled ? 1 : 0);
      },
      parse: function(s) {
        var domain, ref;
        if (!s) {
          return [null, null];
        }
        ref = s.split(';'), domain = ref[0], loopDomain = ref[1], loopDisabled = ref[2];
        domain = domain.split(',').map(parseFloat);
        loopDomain = loopDomain.split(',').map(parseFloat);
        loopDisabled = loopDisabled === '1';
        return [domain, loopDomain, loopDisabled];
      }
    };
    createHistory = function() {
      var domain, historyKey, ref, update;
      if (!(historyKey = timeline.historyKey())) {
        return;
      }
      history = History(historyKey, historyCodec);
      update = function(domain, loopDomain, loopDisabled) {
        if (domain) {
          timeline.domain(domain);
        }
        if (loopDomain) {
          timeline.loop(loopDomain);
        }
        return timeline.loopDisabled(loopDisabled);
      };
      ref = history.get(), domain = ref[0], loopDomain = ref[1], loopDisabled = ref[2];
      update(domain, loopDomain, loopDisabled);
      return history.on('change', function(arg) {
        var domain, end, loopDisabled, loopDomain, ref1, start;
        domain = arg[0], loopDomain = arg[1], loopDisabled = arg[2];
        update(domain, loopDomain, loopDisabled);
        ref1 = loopDomain || [null, null], start = ref1[0], end = ref1[1];
        return dispatch.loopChange(start, end, loopDisabled);
      });
    };
    timeline = function(_selection) {
      var axisOverlay, downTime, downY, dragEnd, dragMove, dragStart, dragging, lastPointerX, lhs, loopOverlay, mousedownHandler, movedSinceDragStart, ref, rhs, width, x;
      selection = _selection;
      x = timeline.x();
      width = Math.abs(x.range()[1] - x.range()[0]);
      axis = d3.svg.axis().scale(x).tickSize(10, 5, 0).ticks((ref = width > 50) != null ? ref : {
        10: 2
      }).tickFormat(formatSeconds);
      setSecondsFormatter();
      dragging = false;
      movedSinceDragStart = false;
      downTime = null;
      downY = null;
      lhs = null;
      rhs = null;
      lastPointerX = null;
      createHistory();
      dragStart = function(pointerX, pointerY) {
        var downDomain;
        d3.event.preventDefault();
        d3.event.stopPropagation();
        x = timeline.x();
        dragging = true;
        movedSinceDragStart = false;
        downY = pointerY;
        downTime = x.invert(pointerX);
        downDomain = x.domain();
        lhs = downTime - downDomain[0];
        rhs = downDomain[1] - downTime;
        if (!d3.event.altKey) {
          dispatch.timeselect(downTime);
        }
        if (!zoomable) {
          return;
        }
        prong._dragging = true;
        return lastPointerX = pointerX;
      };
      dragMove = function() {
        var deltaX, diff, newDomain, pointer, pointerX, pointerY, zoomFactor;
        if (!zoomable) {
          return;
        }
        d3.event.preventDefault();
        d3.event.stopPropagation();
        pointer = d3.mouse(selection.node());
        pointerX = pointer[0];
        pointerY = pointer[1];
        if (isNaN(downY) || !dragging) {
          return;
        }
        x = timeline.x();
        deltaX = pointerX - lastPointerX;
        lastPointerX = pointerX;
        downTime += x.invert(pointerX) - x.invert(pointerX + deltaX);
        diff = pointerY - downY;
        zoomFactor = Math.pow(2, diff / 100);
        newDomain = [downTime - (lhs / zoomFactor), downTime + (rhs / zoomFactor)];
        x.domain(notBelowZero(newDomain));
        movedSinceDragStart = true;
        setSecondsFormatter();
        selection.call(axis.scale(x));
        updateMinorLines(x);
        dispatch.change(x);
        return prong._dragging = true;
      };
      dragEnd = function() {
        dragging = false;
        d3.select(window).on('mousemove.timeline', null).on('mouseup.timeline', null);
        if (movedSinceDragStart) {
          dispatch.end(x);
          if (history) {
            history.set();
          }
        }
        return prong._dragging = false;
      };
      selection.attr('width', width).call(axis);
      updateMinorLines(x);
      axisOverlay = selection.append('rect').attr('class', 'timelineOverlay').attr('x', 0).attr('y', 0).attr('width', width).attr('height', '100%').attr('fill', 'transparent');
      if (canSelectLoop) {
        loopSelector = LoopSelector().timeline(timeline).domain(timeline.loop()).disabled(timeline.loopDisabled()).on('changing', function(start, end, disabled) {
          return dispatch.loopChanging(start, end, disabled);
        }).on('change', function(start, end, disabled) {
          dispatch.loopChange(start, end, disabled);
          if (history) {
            return history.set();
          }
        });
        loopOverlay = selection.append('g').call(loopSelector);
      }
      mousedownHandler = function(d) {
        var pointer;
        pointer = d3.mouse(selection.node());
        dragStart(pointer[0], pointer[1]);
        d3.select(window).on('mousemove.timeline', dragMove).on('mouseup.timeline', dragEnd);
        return d3.event.preventDefault();
      };
      axisOverlay.on('mousedown.timeline', mousedownHandler);
      if (scrollZone) {
        return scrollZone.on('mousedown.timeline', mousedownHandler);
      }
    };
    timeline.fireChange = function() {
      dispatch.change();
      return timeline.redraw();
    };
    timeline.redraw = function() {
      var x;
      x = timeline.x();
      setSecondsFormatter();
      selection.call(axis.scale(x));
      updateMinorLines(x);
      selection.select('.timelineOverlay').attr('width', Math.abs(x.range()[1] - x.range()[0]));
      return timeline;
    };
    timeline.on = function(type, listener) {
      dispatch.on(type, listener);
      return timeline;
    };
    timeline.scrollZone = function(selection) {
      if (!arguments.length) {
        return scrollZone;
      }
      scrollZone = selection;
      if (scrollZone) {
        scrollZone.on('mousewheel', mouseWheel);
        scrollZone.on('DOMMouseScroll', function() {
          if (d3.event.axis === d3.event.HORIZONTAL_AXIS) {
            d3.event.wheelDeltaX = d3.event.detail * -120;
            d3.event.wheelDeltaY = 0;
          } else {
            d3.event.wheelDeltaX = 0;
            d3.event.wheelDeltaY = d3.event.detail * -120;
          }
          return mouseWheel();
        });
      }
      return timeline;
    };
    timeline.zoomable = function(_zoomable) {
      if (!arguments.length) {
        return zoomable;
      }
      zoomable = _zoomable;
      return timeline;
    };
    timeline.canSelectLoop = function(_canSelectLoop) {
      if (!arguments.length) {
        return canSelectLoop;
      }
      canSelectLoop = _canSelectLoop;
      return timeline;
    };
    timeline.domain = function(domain) {
      if (!arguments.length) {
        return timeline.x().domain();
      }
      timeline.x().domain(domain);
      timeline.redraw();
      return dispatch.change(timeline.x());
    };
    timeline.rangeAndDomain = function(range, domain) {
      timeline.x().range(range).domain(domain);
      timeline.redraw();
      dispatch.change(timeline.x());
      return timeline;
    };
    timeline.loop = function(domain) {
      if (!arguments.length) {
        if (loopSelector) {
          return loopSelector.domain();
        } else {
          return loopDomain || [null, null];
        }
      }
      if (loopSelector) {
        loopSelector.domain(domain);
      } else {
        loopDomain = domain;
      }
      return timeline;
    };
    timeline.loopDisabled = function(_disabled) {
      if (!arguments.length) {
        if (loopSelector) {
          return loopSelector.disabled();
        } else {
          return loopDisabled;
        }
      }
      if (loopSelector) {
        loopSelector.disabled(_disabled);
      } else {
        loopDisabled = _disabled;
      }
      return timeline;
    };
    return d3.rebind(timeline, commonProperties(), 'x', 'width', ' height', 'sequence', 'historyKey');
  };

}).call(this);

},{"../":28,"../commonProperties":6,"../history/history":27,"./loopSelector":12,"d3-prong":46}],23:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var commonProperties, d3, playStopButton;

  commonProperties = require('../commonProperties');

  playStopButton = require('./playStopButton');

  d3 = require('d3-prong');

  module.exports = function() {
    var transport;
    transport = function(selection) {
      var playStop;
      playStop = playStopButton().on('change', function(playing) {
        var sequence;
        sequence = transport.sequence();
        if (!sequence) {
          return;
        }
        if (playing) {
          return sequence.play();
        } else {
          if (sequence.playing()) {
            return sequence.stop();
          } else {
            return sequence.currentTime(0);
          }
        }
      });
      selection.append('div').call(playStop);
      if (transport.sequence()) {
        return transport.sequence().on('play', function(playing) {
          return playStop.playing(transport.sequence().playing());
        });
      }
    };
    return d3.rebind(transport, commonProperties(), 'sequence');
  };

}).call(this);

},{"../commonProperties":6,"./playStopButton":17,"d3-prong":46}],24:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var DISPLAY_ABOVE_AND_BELOW_CUTOFF, DISPLAY_AS_LINE_CUTOFF, commonProperties, d3, domainWidth, preparePcmData, uid;

  commonProperties = require('../commonProperties');

  preparePcmData = require('./preparePcmData');

  uid = require('../uid');

  d3 = require('d3-prong');

  DISPLAY_ABOVE_AND_BELOW_CUTOFF = 10;

  DISPLAY_AS_LINE_CUTOFF = 1;

  domainWidth = function(domain) {
    return domain[1] - domain[0];
  };

  module.exports = function() {
    var verticalZoom, waveform;
    verticalZoom = 1;
    waveform = function() {
      var draw, drawAndTime, drawSection, drawSections, drawingTime, lastDrawingStart, lastTimeout, roundedY, selection, timeline, width, x, y;
      selection = this;
      x = waveform.x();
      width = waveform.width();
      y = d3.scale.linear().range([waveform.height(), 0]).domain([1 / verticalZoom, -1 / verticalZoom]);
      roundedY = function(d) {
        return d3.round(y(d), 1);
      };
      drawSection = function(container, data, sampleX, offset, samplesPerPixel, cls) {
        var area, g;
        g = container.append('g');
        if (cls) {
          g.classed(cls, true);
        }
        area = d3.svg.area().x(function(_, i) {
          var ret;
          ret = d3.round(sampleX(i + offset), 1);
          return ret;
        });
        if (samplesPerPixel > DISPLAY_ABOVE_AND_BELOW_CUTOFF) {
          area.y0(function(d) {
            return roundedY(-Math.abs(d));
          }).y1(function(d) {
            return roundedY(Math.abs(d));
          });
        } else {
          area.y0(roundedY(0)).y1(roundedY);
        }
        return g.classed('area', 'true').append('path').datum(data).attr('d', area);
      };
      drawSections = function(x, sections) {
        return selection.each(function(d) {
          var container, data, e, j, lastE, len, ref, ref1, results, s, sampleX, samplesPerPixel, section, subdata;
          container = d3.select(this);
          container.selectAll('.area').remove();
          container.selectAll('.line').remove();
          ref = preparePcmData(d, x), data = ref[0], sampleX = ref[1], samplesPerPixel = ref[2];
          if (data) {
            lastE = null;
            results = [];
            for (j = 0, len = sections.length; j < len; j++) {
              section = sections[j];
              ref1 = section.domain.map(x).map(sampleX.invert), s = ref1[0], e = ref1[1];
              if (e < 0) {
                continue;
              }
              s = Math.max(0, s);
              s = lastE ? lastE - 1 : Math.floor(s);
              e = lastE = Math.ceil(e);
              subdata = data.slice(s, e);
              results.push(drawSection(container, subdata, sampleX, s, samplesPerPixel, section["class"]));
            }
            return results;
          }
        });
      };
      draw = function() {
        var end, loopEnd, loopStart, ref, ref1, ref2, start, timeline;
        if ((timeline = waveform.timeline()) && (!timeline.loopDisabled())) {
          ref = waveform.timeline().loop(), loopStart = ref[0], loopEnd = ref[1];
        } else {
          ref1 = [null, null], loopStart = ref1[0], loopEnd = ref1[1];
        }
        ref2 = x.domain(), start = ref2[0], end = ref2[1];
        if (loopStart === null || loopEnd === null || loopEnd <= start || loopStart >= end) {
          return drawSections(x, [
            {
              domain: [start, end]
            }
          ]);
        } else {
          if (loopStart > start && loopStart < end) {
            if (loopEnd < end && loopEnd > start) {
              return drawSections(x, [
                {
                  domain: [start, loopStart]
                }, {
                  domain: [loopStart, loopEnd],
                  "class": 'loop'
                }, {
                  domain: [loopEnd, end]
                }
              ]);
            } else {
              return drawSections(x, [
                {
                  domain: [start, loopStart]
                }, {
                  domain: [loopStart, end],
                  "class": 'loop'
                }
              ]);
            }
          } else {
            if (loopEnd < end && loopEnd > start) {
              return drawSections(x, [
                {
                  domain: [start, loopEnd],
                  "class": 'loop'
                }, {
                  domain: [loopEnd, end]
                }
              ]);
            } else {
              return drawSections(x, [
                {
                  domain: [start, end],
                  "class": 'loop'
                }
              ]);
            }
          }
        }
      };
      draw();
      timeline = waveform.timeline();
      if (timeline) {
        lastTimeout = null;
        drawingTime = null;
        lastDrawingStart = null;
        drawAndTime = function() {
          var start;
          start = new Date();
          draw();
          return drawingTime = new Date() - start;
        };
        timeline.on('change.' + uid(), function() {
          var after;
          if (lastTimeout) {
            clearTimeout(lastTimeout);
          }
          if ((!lastDrawingStart) || (new Date() - lastDrawingStart) > (drawingTime * 2)) {
            return drawAndTime();
          } else {
            after = function() {
              drawAndTime();
              return lastTimeout = null;
            };
            return lastTimeout = setTimeout(after, 50);
          }
        });
        timeline.on('loopChanging.' + uid(), draw);
        return timeline.on('loopChange.' + uid(), draw);
      }
    };
    waveform.verticalZoom = function(_verticalZoom) {
      if (!arguments.length) {
        return verticalZoom;
      }
      verticalZoom = _verticalZoom;
      return waveform;
    };
    return d3.rebind(waveform, commonProperties(), 'x', 'width', 'height', 'timeline');
  };

}).call(this);

},{"../commonProperties":6,"../uid":42,"./preparePcmData":19,"d3-prong":46}],25:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var s4;

  s4 = function() {
    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  };

  module.exports = function() {
    return s4() + s4();
  };

}).call(this);

},{}],26:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var frameRate, parse, roundToFrame, stringify, unround;

  frameRate = 15;

  roundToFrame = function(time) {
    return d3.round(Math.round(time * frameRate) / frameRate, 3);
  };

  unround = function(time) {
    return Math.round(time * frameRate) / frameRate;
  };

  stringify = function(editList) {
    var e;
    e = (editList.map(function(edit, i) {
      var a;
      a = [edit.track, roundToFrame(edit.start)];
      if (edit.end) {
        if (i === (editList.length - 1) || edit.end !== editList[i + 1].start) {
          a.push(roundToFrame(edit.end));
        }
      }
      return a.join(',');
    })).join(';');
    return e;
  };

  parse = function(s) {
    var editList, edits;
    if (!s) {
      return [
        {
          'track': 0,
          start: 0
        }
      ];
    }
    edits = s.split(';');
    editList = [];
    edits.forEach(function(editData) {
      var b, edit, start, track;
      b = editData.split(',');
      track = parseInt(b[0]);
      start = unround(parseFloat(b[1]));
      edit = {
        'track': track,
        'start': start
      };
      if (b.length > 2) {
        edit.end = unround(parseFloat(b[2]));
      }
      return editList.push(edit);
    });
    return editList;
  };

  module.exports = {
    stringify: stringify,
    parse: parse
  };

}).call(this);

},{}],27:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var d3;

  d3 = require('d3-prong');

  module.exports = function(id, codec) {
    var current, dispatch, history, later, suppressEvents;
    dispatch = d3.dispatch('change');
    history = {};
    suppressEvents = false;
    current = null;
    history.get = function() {
      var hash, match, re, separator, value;
      hash = unescape(window.location.hash);
      hash = hash.replace(/\+/g, ' ');
      re = new RegExp("[#|&]" + id + "=(.*?)(&|$)", "i");
      separator = hash.indexOf('#') !== -1 ? "&" : "#";
      match = hash.match(re);
      value = match ? match[1] : null;
      if (codec) {
        value = codec.parse(value);
      }
      return value;
    };
    history.set = function(value, description) {
      var currentTitle, hash, re, separator;
      current = value;
      if (codec) {
        value = codec.stringify(value);
      }
      value = value.replace(/\s/g, '+');
      suppressEvents = true;
      hash = unescape(window.location.hash);
      re = new RegExp("([#|&])" + id + "=.*?(&|$)", "i");
      separator = hash.indexOf('#') !== -1 ? "&" : "#";
      if (hash.match(re)) {
        hash = hash.replace(re, '$1' + id + "=" + value + '$2');
      } else {
        hash += separator + id + "=" + value;
      }
      currentTitle = window.document.title;
      if (description) {
        window.document.title = currentTitle + ' - ' + description;
      }
      window.location.hash = hash;
      if (description) {
        window.document.title = currentTitle;
      }
      return suppressEvents = false;
    };
    later = function() {
      var popstateListener;
      popstateListener = function(e) {
        var newValue;
        if (!suppressEvents) {
          newValue = history.get();
          if (newValue !== current) {
            current = newValue;
            return dispatch.change(newValue);
          }
        }
      };
      window.addEventListener("popstate", popstateListener, false);
      return current = history.get();
    };
    setTimeout(later, 1);
    history.on = function(type, listener) {
      dispatch.on(type, listener);
      return history;
    };
    return history;
  };

}).call(this);

},{"d3-prong":46}],28:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var sound;

  sound = require('./sound');

  module.exports = {
    spectrogram: require('./components/spectrogram'),
    waveform: require('./components/waveform'),
    canvasWaveform: require('./components/canvasWaveform'),
    filmstrip: require('./components/filmstrip'),
    onsets: require('./components/onsets'),
    comper: require('./components/comper'),
    timeline: require('./components/timeline'),
    musicalTimeline: require('./components/musicalTimeline'),
    musicalTime: require('./musicalTime'),
    slider: require('./components/slider'),
    pot: require('./components/pot'),
    contour: require('./components/contour'),
    lines: require('./components/lines'),
    mixer: require('./components/mixer'),
    transport: require('./components/transport'),
    history: require('./history/history'),
    omniscience: require('./omniscience'),
    sequence: require('./sequence'),
    registerTrackType: require('./track/track').registerTrackType,
    uid: require('./uid'),
    guid: require('./guid'),
    audioContext: require('./audioContext'),
    sound: sound.sound,
    sounds: sound.sounds,
    organ: require('./organ'),
    organController: require('./components/organController'),
    d3: require('d3-prong')
  };

}).call(this);

},{"./audioContext":4,"./components/canvasWaveform":7,"./components/comper":8,"./components/contour":9,"./components/filmstrip":10,"./components/lines":11,"./components/mixer":13,"./components/musicalTimeline":14,"./components/onsets":15,"./components/organController":16,"./components/pot":18,"./components/slider":20,"./components/spectrogram":21,"./components/timeline":22,"./components/transport":23,"./components/waveform":24,"./guid":25,"./history/history":27,"./musicalTime":29,"./omniscience":30,"./organ":31,"./sequence":34,"./sound":35,"./track/track":39,"./uid":42,"d3-prong":46}],29:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var MusicalTime, d3,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  d3 = require('d3-prong');

  MusicalTime = (function() {
    MusicalTime.RESOLUTION = 16384;

    MusicalTime.barLength = function(chunk) {
      return chunk.numerator * 60 / chunk.tempo;
    };

    function MusicalTime(bars) {
      this._fleshOutBars = bind(this._fleshOutBars, this);
      this.bars = bars;
      this._scale = d3.scale.linear();
      this._fleshOutBars();
    }

    MusicalTime.prototype.getBarAndBeatAtTime = function(time, quantize) {
      var bar, barTime, beat, denominator, fractionOfBar, numerator, quarterNotesPerBar, ref;
      barTime = this._scale.invert(time);
      bar = ~~barTime;
      fractionOfBar = barTime - bar;
      ref = this.getTimeSignatureAtBar(bar), numerator = ref[0], denominator = ref[1];
      quarterNotesPerBar = numerator * 4 / denominator;
      beat = Math.round(fractionOfBar * quarterNotesPerBar * (quantize / 4)) / (quantize / 4);
      while (beat >= numerator) {
        beat -= numerator;
        bar += 1;
      }
      return [bar, beat];
    };

    MusicalTime.prototype.getTimeSignatureAtBar = function(barNumber) {
      var barGroup, i;
      i = 0;
      barGroup = this.bars[i];
      while (barGroup.startBarNumber < barNumber) {
        barGroup = this.bars[++i];
      }
      return [barGroup.numerator, barGroup.denominator];
    };

    MusicalTime.prototype.ticksToPixels = function(x) {
      var domain, range;
      domain = this.bars.map(function(chunk) {
        return chunk.startTick;
      });
      domain.push(this.bars.slice(-1)[0].endTick);
      range = this._scale.range().map(x);
      return d3.scale.linear().domain(domain).range(range);
    };

    MusicalTime.prototype.barsToPixels = function(x) {
      var domain, range;
      domain = this._scale.domain();
      range = this._scale.range().map(x);
      return d3.scale.linear().domain(domain).range(range);
    };

    MusicalTime.prototype.beats = function(start, duration, quantize) {
      var barTime, beats, denominator, numerator, ref;
      barTime = this._scale.invert(start);
      duration = this._scale.invert(start + duration) - barTime;
      ref = this.getTimeSignatureAtBar(~~barTime), numerator = ref[0], denominator = ref[1];
      beats = Math.round(duration * numerator * (quantize / 4)) / (quantize / 4);
      if (beats < 1) {
        beats = 1;
      }
      return beats;
    };

    MusicalTime.prototype._fleshOutBars = function() {
      var barNumber, domain, lastDenominator, range, tempo, tick, time;
      lastDenominator = 4;
      tempo = this.bars[0].tempo;
      time = this.bars[0].startTime;
      if (!tempo) {
        throw 'Must specify tempo for the first group of bars';
      }
      if (time === null) {
        throw 'Must specify the start time (in seconds) for the first group of bars';
      }
      barNumber = 1;
      tick = 0;
      this.bars.forEach(function(chunk) {
        if (!('tempo' in chunk)) {
          chunk.tempo = tempo * chunk.denominator / lastDenominator;
        }
        tempo = chunk.tempo;
        lastDenominator = chunk.denominator;
        chunk.startTime = time;
        time += chunk.numberOfBars * MusicalTime.barLength(chunk);
        chunk.startBarNumber = barNumber;
        barNumber += chunk.numberOfBars;
        chunk.startTick = tick;
        tick += chunk.numberOfBars * chunk.numerator * MusicalTime.RESOLUTION / chunk.denominator;
        return chunk.endTick = tick;
      });
      this.endTime = time;
      this.finalBarNumber = barNumber - 1;
      domain = this.bars.map(function(chunk) {
        return chunk.startBarNumber;
      });
      domain.push(this.finalBarNumber + 1);
      range = this.bars.map(function(chunk) {
        return chunk.startTime;
      });
      range.push(this.endTime);
      return this._scale.domain(domain).range(range);
    };

    return MusicalTime;

  })();

  module.exports = MusicalTime;

}).call(this);

},{"d3-prong":46}],30:[function(require,module,exports){
/*
Allows you to watch a parent object, and receive event notifications when
any property changes on any property of the object, or any property of any
child object, all the way down the tree of descendants.
*/


/* 
This object.watch code is borrowed from https://gist.github.com/eligrey/384583,
with some modifications, mainly to allow multiple handlers on a single
property. This enables us to receive events when properties
change on objects
*/
if (!Object.prototype.watch) {

    Object.defineProperty(Object.prototype, 'watch', {
        enumerable: false,
        configurable: true,
        writable: false,
        value: function (prop, handler) {

            if (!this.hasOwnProperty('_watchHandlers')){
                Object.defineProperty(this, '_watchHandlers', {
                    enumerable : false,
                    configurable : false,
                    writable : false,
                    value : {}
                })
            }

            var watchHandlers = this._watchHandlers;
            if (!(prop in watchHandlers)){
                watchHandlers[prop] = []
            }
            watchHandlers[prop].push(handler);
            var thiz = this;

            var oldval = this[prop],
                newval = oldval,
                getter = function () {
                    return newval;
                },
                setter = function (val) {
                    oldval = newval;
                    newval = val;
                    if (newval != oldval){
                        thiz._watchHandlers[prop].forEach(function(handler){
                            handler.call(thiz, prop, oldval, val);
                        })
                    }
                    return val;
                };
            
            if (delete this[prop]) { // can't watch constants
                Object.defineProperty(this, prop, {
                    get: getter,
                    set: setter,
                    enumerable: true,
                    configurable: true
                });
            }
        }
    });
}
 
// object.unwatch
if (!Object.prototype.unwatch) {
    Object.defineProperty(Object.prototype, 'unwatch', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: function (prop) {
                var val = this[prop];
                delete this[prop]; // remove accessors
                this[prop] = val;
            }
    });
}

/* walk all the descendants of the parent[key] object, calling the callback
for each one. The path argument is simply passed on to the callback
*/
function walk(parent, key, callback, path){

    if (!path){
        path = key
    }else{
        path += ',' + key;
    }

    callback(parent, key, path);
    
    if (typeof(parent[key]) == 'object'){
         Object.keys(parent[key]).forEach(function(_key){
            walk(parent[key], _key, callback, path)
        })
    }
}

function getObjectFromPath(parent, path){
    var current = parent;
    path.forEach(function(prop){
        current = current[prop]
    })
    return current;
}

module.exports =  function(parent, key){
    var omniscience = {},
        dispatch = d3.dispatch('propertyChange');

    function setupWatches(parent, key, path){
        walk(parent, key, function(_parent, _key, path){
            _parent.watch(_key, function(property, oldValue, newValue){
                changeHandler(path.split(','), newValue, oldValue)
            })
        }, path)
    }

    setupWatches(parent, key);

    function changeHandler(path, newValue, oldValue){
        // if the new value is an object, then we need to set up new watches
        // on it
        if (typeof(newValue) == 'object'){
            var p = getObjectFromPath(parent, path);
            Object.keys(p).forEach(function(k){
                setupWatches(p, k, path.join(','))
            })

            // TODO : unwatch the old value?
        }

        dispatch.propertyChange(parent, path, newValue, oldValue);
        path.slice(1)
    }

    /* for attaching event listeners to this omniscience object */
    omniscience.on = function(type, listener){
        dispatch.on(type, listener)
        return omniscience;
    }

    return omniscience;
}
},{}],31:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  module.exports = function() {
    var context, gain, imaginary, isOn, organ, osc, real, setWave, volume;
    context = require('./audioContext')();
    real = new Float32Array([0, 1, 0, 1]);
    imaginary = new Float32Array([0, 0, 0, 0]);
    isOn = false;
    volume = 0;
    osc = context.createOscillator();
    osc.frequency.value = 160;
    gain = context.createGain();
    osc.connect(gain);
    gain.connect(context.destination);
    gain.gain.value = volume;
    osc.start(0);
    setWave = function() {
      var waveTable;
      waveTable = context.createPeriodicWave(real, imaginary);
      return osc.setPeriodicWave(waveTable);
    };
    setWave();
    organ = {};
    organ.frequencyComponents = function(arg) {
      var _imaginary, _real;
      _real = arg[0], _imaginary = arg[1];
      if (!arguments.length) {
        return [real, imaginary];
      }
      real = new Float32Array(_real);
      imaginary = new Float32Array(_imaginary);
      setWave();
      return this;
    };
    organ.volume = function(_volume) {
      if (!arguments.length) {
        return volume;
      }
      volume = _volume;
      if (isOn) {
        gain.gain.value = volume;
      }
      return this;
    };
    organ.on = function(_on) {
      if (_on == null) {
        _on = true;
      }
      if (!arguments.length) {
        return isOn;
      }
      if (_on) {
        gain.gain.value = volume;
      } else {
        gain.gain.value = 0;
      }
      isOn = _on;
      return this;
    };
    organ.start = function() {
      return organ.on(true);
    };
    organ.stop = function() {
      return organ.on(false);
    };
    return organ;
  };

}).call(this);

},{"./audioContext":4}],32:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2

/*
A non-visual component which keeps track of a number of audio resources,
typically when these are shared by different regions in a track
 */

(function() {
  var async, sound;

  sound = require('./sound').sound;

  async = require('async');

  module.exports = function(_clips) {
    var clips, loadCallbacks, loaded, pool, urls;
    clips = _clips;
    urls = clips.map(function(r) {
      return r.src;
    });
    pool = {};
    loaded = false;
    loadCallbacks = [];
    pool.getClipById = function(id, callback) {
      var clip;
      clip = clips.filter(function(r) {
        return r.id === id;
      });
      if (clip.length !== 1) {
        throw (clip.length ? "Pool clip id not unique" : "Pool clip id not found");
      } else {
        clip = clip[0];
        if (clip._buffer) {
          return callback(clip);
        } else if (clip._loading) {
          return clip._loadCallbacks.push(callback);
        } else {
          clip._loading = true;
          clip._loadCallbacks = [];
          return sound(clip.src, function(buffer) {
            clip._buffer = buffer;
            clip._channel = buffer.getChannelData(0);
            clip._loading = false;
            if (clip._loadCallbacks) {
              clip._loadCallbacks.forEach(function(cb) {
                return cb(clip);
              });
            }
            return callback(clip);
          });
        }
      }
    };
    pool.clips = function() {
      loaded = false;
      return clips;
    };
    return pool;
  };

}).call(this);

},{"./sound":35,"async":44}],33:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  module.exports = {};

}).call(this);

},{}],34:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var MusicalTimeline, Pool, Timeline, Track, commonProperties, d3;

  d3 = require('d3-prong');

  commonProperties = require('./commonProperties');

  Track = require('./track/track');

  Timeline = require('./components/timeline');

  MusicalTimeline = require('./components/musicalTimeline');

  Pool = require('./pool');

  module.exports = function() {
    var _track, audioOut, canSelectLoop, container, currentTime, dispatch, element, following, loopDisabled, loopDomain, musicalTime, playLine, playStartComputerTime, playStartSequenceTime, playing, pool, propertyPanelWidth, scrollZone, scrubbing, sequence, setPlaylinePosition, timeline, timelineHeight, trackHeight, trackLoadCount, tracks, tracksContainer, waveformVerticalZoom, zoomable;
    element = null;
    tracksContainer = null;
    container = null;
    tracks = [];
    _track = null;
    playLine = null;
    scrubbing = false;
    playing = false;
    currentTime = 0;
    audioOut = null;
    trackHeight = null;
    trackLoadCount = 0;
    timelineHeight = 40;
    waveformVerticalZoom = 1;
    pool = null;
    dispatch = d3.dispatch('scrub', 'change', 'play', 'stop', 'loop', 'tick', 'load', 'volumeChange');
    scrollZone = null;
    timeline = null;
    musicalTime = null;
    zoomable = true;
    following = true;
    propertyPanelWidth = 95;
    canSelectLoop = false;
    loopDomain = [null, null];
    loopDisabled = false;
    setPlaylinePosition = function() {
      var end, position, ref, start, x;
      x = sequence.x();
      ref = x.domain(), start = ref[0], end = ref[1];
      if (currentTime < start || currentTime > end) {
        return playLine.style('display', 'none');
      } else {
        position = (x(currentTime)) + propertyPanelWidth;
        playLine.style('display', '');
        return playLine.style('left', position + 'px');
      }
    };
    sequence = function(_element) {
      var historyKey, mouse, musicalTimeline, playlineContainer, propertyPanel, timelineContainer, timelineSvg, x;
      element = _element;
      x = sequence.x();
      timeline = Timeline().x(x).sequence(sequence).zoomable(zoomable).canSelectLoop(canSelectLoop).scrollZone(scrollZone || element).loop(loopDomain).loopDisabled(loopDisabled);
      if (historyKey = sequence.historyKey()) {
        timeline.historyKey(historyKey + 'tl');
      }
      element.classed('sequence', true);
      propertyPanel = element.append('div').style('width', propertyPanelWidth + 'px').style('height', (tracks.length * trackHeight + timelineHeight) + "px").attr('class', 'propertyPanel');
      container = element.append('div').attr('class', 'trackContainer').style('left', propertyPanelWidth + 'px');
      playlineContainer = container.append('div').style('position', 'absolute').attr('class', 'playlineContainer');
      timelineContainer = container.append('div').style('height', timelineHeight + 'px').style('width', '100%').attr('class', 'timelineContainer');
      timelineSvg = timelineContainer.append('svg').style('position', 'absolute').attr('height', 300).attr('width', '100%').attr('class', 'timeline');
      timelineSvg.append('g').attr('transform', 'translate(0,15)').call(timeline);
      if (musicalTime) {
        timelineHeight += 30;
        timelineContainer.style('height', timelineHeight + 'px');
        musicalTimeline = MusicalTimeline().musicalTime(musicalTime).timeline(timeline);
        timelineSvg.append('g').attr('transform', 'translate(0,45)').call(musicalTimeline);
      }
      tracksContainer = container.append('div').attr('width', '100%');
      mouse = function() {
        var reference, touches;
        touches = d3.event.changedTouches;
        reference = timelineContainer;
        if (touches) {
          return d3.touches(referece, touches)[0];
        } else {
          return d3.mouse(reference.node());
        }
      };
      sequence.timeline(timeline);
      _track = Track().sequence(sequence);
      tracksContainer.datum(tracks).call(_track);
      _track.on('load', function() {
        trackLoadCount++;
        if (trackLoadCount === tracks.length) {
          dispatch.load();
        }
        playLine.style('height', sequence.height() + 'px');
        return propertyPanel.style('height', sequence.height() + 'px');
      });
      playLine = playlineContainer.append('div').style('height', '100px').attr('class', 'playLine').style('top', '15px');
      setPlaylinePosition();
      timeline.on('change.playline', function() {
        return setPlaylinePosition();
      });
      timeline.on('timeselect', function(time) {
        if (!scrubbing) {
          currentTime = time;
          setPlaylinePosition();
          if (playing) {
            sequence.stop();
            sequence.play(time);
          }
          return dispatch.tick();
        }
      });
      element.on('mousemove', function() {
        var mouseX, time;
        if (!playing && scrubbing) {
          mouseX = mouse()[0];
          time = x.invert(mouseX);
          time = Math.max(time, x.domain()[0]);
          setPlaylinePosition();
          currentTime = time;
          return dispatch.scrub(time);
        }
      });
      return element.on('dblclick', function() {
        var mouseX, time;
        if (playing) {
          sequence.stop();
          return;
        }
        mouseX = mouse()[0];
        time = x.invert(mouseX);
        time = Math.max(time, x.domain()[0]);
        return sequence.play(time);
      });
    };
    sequence.tracks = function(_tracks) {
      var existingIds, id, newTracks;
      if (!arguments.length) {
        return tracks;
      }
      Track.unpackTrackData(_tracks);
      _tracks.forEach(function(track) {
        if (!('volume' in track)) {
          track.volume = 60;
        }
        if (!('pan' in track)) {
          return track.pan = 0;
        }
      });
      id = function(track) {
        if ('id' in track) {
          return track.id;
        }
        if ('src' in track) {
          return track.src;
        }
        return track.name;
      };
      newTracks = [];
      existingIds = tracks.map(id);
      _tracks.forEach(function(track) {
        var existingTrackIndex, key, oldTrack, trackId;
        trackId = id(track);
        existingTrackIndex = existingIds.indexOf(trackId);
        if (existingTrackIndex !== -1) {
          oldTrack = tracks[existingTrackIndex];
          for (key in track) {
            if (typeof track[key] === 'number' || typeof track[key] === 'string') {
              if (track[key] !== oldTrack) {
                oldTrack[key] = track[key];
              }
            }
          }
          return newTracks.push(oldTrack);
        } else {
          return newTracks.push(track);
        }
      });
      tracks = newTracks;
      return sequence;
    };
    sequence.addTrack = function(track) {
      tracks.push(track);
      return sequence.redraw();
    };
    sequence.removeTrack = function(track) {
      var i;
      i = tracks.indexOf(track);
      tracks.splice(i, 1);
      return sequence.redraw();
    };
    sequence.fireChange = function() {
      return dispatch.change();
    };
    sequence.redraw = function() {
      var join;
      join = tracksContainer.selectAll('.track').data(tracks, function(d) {
        return d.src;
      });
      join.enter().append('div').attr('class', 'track').call(_track);
      join.exit().each(function(d, i) {
        if (d.cleanup) {
          return d.cleanup();
        }
      }).remove();
      return setPlaylinePosition();
    };
    sequence.redrawContents = function(options) {
      return tracksContainer.selectAll('.track').data(tracks, function(d) {
        return d.src;
      }).call(_track, options);
    };
    sequence.scrubbing = function(_scrubbing) {
      if (!arguments.length) {
        return scrubbing;
      }
      scrubbing = _scrubbing;
      return sequence;
    };
    sequence.on = function(type, listener) {
      dispatch.on(type, listener);
      return sequence;
    };
    playStartSequenceTime = null;
    playStartComputerTime = null;
    sequence.play = function(time) {
      var loopEnd, loopStart, ref, startTime, startTimestamp, tick, x;
      if (playing) {
        console.log('already playing, so returning');
        return;
      }
      ref = timeline.loop(), loopStart = ref[0], loopEnd = ref[1];
      if (time === void 0 && loopStart !== null && loopEnd !== null && (!timeline.loopDisabled())) {
        time = loopStart;
      }
      currentTime = time || currentTime;
      playStartSequenceTime = currentTime;
      playStartComputerTime = new Date();
      playing = true;
      dispatch.play(currentTime);
      x = sequence.x();
      startTimestamp = Date.now();
      startTime = currentTime;
      tick = function() {
        var domain, looping, ref1, width;
        currentTime = ((Date.now() - startTimestamp) / 1000) + startTime;
        ref1 = sequence.loop(), loopStart = ref1[0], loopEnd = ref1[1];
        looping = (!sequence.loopDisabled()) && loopStart !== null;
        if (looping && (currentTime > loopEnd || currentTime < loopStart)) {
          currentTime = loopStart;
          playStartSequenceTime = currentTime;
          playStartComputerTime = new Date();
          startTimestamp = Date.now();
          startTime = currentTime;
          setPlaylinePosition();
          dispatch.loop(loopStart);
          return false;
        } else {
          dispatch.tick(currentTime);
        }
        if (following) {
          domain = x.domain();
          if (currentTime > domain[1]) {
            width = domain[1] - domain[0];
            domain = [domain[0] + width, domain[1] + width];
            sequence.timeline().domain(domain);
          }
        }
        setPlaylinePosition();
        return !playing;
      };
      return d3.timer(tick, 50);
    };
    sequence.playing = function() {
      return playing;
    };
    sequence.stop = function() {
      playing = false;
      playStartSequenceTime = null;
      playStartComputerTime = null;
      return dispatch.stop();
    };
    sequence.currentTime = function(_currentTime) {
      if (!arguments.length) {
        if (playing) {
          currentTime = playStartSequenceTime + (new Date() - playStartComputerTime) / 1000;
        }
        return currentTime;
      }
      currentTime = _currentTime;
      setPlaylinePosition();
      return sequence;
    };
    sequence.audioOut = function(_audioOut) {
      if (!arguments.length) {
        return audioOut;
      }
      audioOut = _audioOut;
      return sequence;
    };
    sequence.trackHeight = function(_trackHeight) {
      if (!arguments.length) {
        return trackHeight;
      }
      trackHeight = _trackHeight;
      return sequence;
    };
    sequence.musicalTime = function(_musicalTime) {
      if (!arguments.length) {
        return musicalTime;
      }
      musicalTime = _musicalTime;
      return sequence;
    };
    sequence.waveformVerticalZoom = function(_waveformVerticalZoom) {
      if (!arguments.length) {
        return waveformVerticalZoom;
      }
      waveformVerticalZoom = _waveformVerticalZoom;
      return sequence;
    };
    sequence.trackVolume = function(trackIndex, volume) {
      tracks[trackIndex].volume = volume;
      return dispatch.volumeChange();
    };
    sequence.poolResources = function(resources) {
      if (!arguments.length) {
        return pool.resources();
      }
      pool = Pool(resources);
      return sequence;
    };
    sequence.pool = function() {
      if (arguments.length) {
        throw "Cannot set pool directly. Set the poolResources instead";
      }
      return pool;
    };
    sequence.scrollZone = function(_scrollZone) {
      if (!arguments.length) {
        return scrollZone;
      }
      scrollZone = _scrollZone;
      return sequence;
    };
    sequence.zoomable = function(_zoomable) {
      if (!arguments.length) {
        return zoomable;
      }
      zoomable = _zoomable;
      return sequence;
    };
    sequence.rangeAndDomain = function(range, domain) {
      return sequence.timeline().rangeAndDomain(range, domain);
    };
    sequence.height = function() {
      return container.node().clientHeight;
    };
    sequence.propertyPanelWidth = function(_propertyPanelWidth) {
      if (!arguments.length) {
        return propertyPanelWidth;
      }
      propertyPanelWidth = _propertyPanelWidth;
      return sequence;
    };
    sequence.canSelectLoop = function(_canSelectLoop) {
      if (!arguments.length) {
        return canSelectLoop;
      }
      canSelectLoop = _canSelectLoop;
      return sequence;
    };
    sequence.loop = function(domain) {
      if (!arguments.length) {
        if (timeline) {
          return timeline.loop();
        } else {
          return loopDomain || [null, null];
        }
      }
      if (timeline) {
        timeline.loop(domain);
      } else {
        loopDomain = domain;
      }
      canSelectLoop = true;
      return sequence;
    };
    sequence.loopDisabled = function(_loopDisabled) {
      if (!arguments.length) {
        if (timeline) {
          return timeline.loopDisabled();
        } else {
          return loopDisabled;
        }
      }
      if (timeline) {
        timeline.loopDisabled(_loopDisabled);
      } else {
        loopDisabled = _loopDisabled;
      }
      canSelectLoop = true;
      return sequence;
    };
    return d3.rebind(sequence, commonProperties(), 'x', 'width', 'sequence', 'timeline', 'historyKey');
  };

}).call(this);

},{"./commonProperties":6,"./components/musicalTimeline":14,"./components/timeline":22,"./pool":32,"./track/track":39,"d3-prong":46}],35:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var audioContext, bufferOffset, sound, sounds;

  audioContext = require('./audioContext')();

  bufferOffset = require('./bufferOffset');

  sound = function(url, callback, onprogress) {
    var request;
    request = new XMLHttpRequest;
    request.open('GET', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function() {
      var s;
      s = request.status;
      if (onprogress) {
        onprogress('decoding...');
      }
      return audioContext.decodeAudioData(request.response, function(buffer) {
        buffer.sampleOffset = bufferOffset(url);
        return callback(buffer);
      });
    };
    if (onprogress) {
      request.onprogress = function(e) {
        var percent;
        if (e.lengthComputable) {
          percent = 100 * e.loaded / e.total;
          return onprogress('loading (' + parseInt(percent) + '%)');
        }
      };
    }
    return request.send(null);
  };

  sounds = function(urls, callback) {
    var buffers, loaded;
    buffers = [];
    loaded = 0;
    return urls.forEach(function(url, i) {
      return sound(url, function(buffer) {
        buffers[i] = buffer;
        loaded++;
        if (loaded >= urls.length) {
          return callback(buffers);
        }
      });
    });
  };

  module.exports = {
    sound: sound,
    sounds: sounds
  };

}).call(this);

},{"./audioContext":4,"./bufferOffset":5}],36:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var AudioContext, Onsets, Waveform, commonProperties, d3, global, sound, trackName, uid;

  d3 = require('d3-prong');

  commonProperties = require('../commonProperties');

  sound = require('../sound').sound;

  Waveform = require('../components/waveform');

  Onsets = require('../components/onsets');

  uid = require('../uid');

  global = require('../prongGlobal');

  trackName = require('../trackName');

  AudioContext = require('../audioContext');

  module.exports = function() {
    var audio, dispatch, getFirstNonBlankChannel, getNonBlankChannelIndexes, httpSoundLoader, width;
    width = null;
    dispatch = d3.dispatch('load');
    getFirstNonBlankChannel = function(buffer) {
      var nonBlankChannels;
      nonBlankChannels = getNonBlankChannelIndexes(buffer);
      if (nonBlankChannels.length > 0) {
        return buffer.getChannelData(nonBlankChannels[0]);
      }
    };
    getNonBlankChannelIndexes = function(buffer) {
      var channel, i, j, nonBlankChannels, ref, someNonZero;
      nonBlankChannels = [];
      for (i = j = 0, ref = buffer.numberOfChannels; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        channel = buffer.getChannelData(i);
        someNonZero = channel.some(function(value) {
          return value > 0;
        });
        if (someNonZero) {
          nonBlankChannels.push(i);
        }
      }
      return nonBlankChannels;
    };
    httpSoundLoader = function(loadingMessage, callback) {
      var onloaded, onprogress, track;
      track = this;
      onprogress = function(message) {
        return loadingMessage.text(message);
      };
      onloaded = function(buffer) {
        track._buffer = buffer;
        track._channel = getFirstNonBlankChannel(track._buffer);
        return callback();
      };
      return sound(track.src, onloaded, onprogress);
    };
    audio = function(selection) {
      return selection.each(function(d, i) {
        var _uid, div, height, loadingMessage, play, playing, sequence, src, svg, x;
        sequence = audio.sequence();
        x = sequence.x();
        width = sequence.width();
        height = d.height || sequence.trackHeight() || 128;
        div = d3.select(this);
        if (!('volume' in d)) {
          d.volume = 1;
        }
        div.append('div').attr('class', 'trackName').append('span').text(trackName);
        loadingMessage = div.append('span').attr('class', 'trackLoading');
        svg = div.append('svg').attr('height', height).attr('width', '100%').on('mouseover', function(d) {
          if (!global._dragging) {
            d3.select(this).classed('over', true);
            return d.over = true;
          }
        }).on('mouseout', function(d) {
          d3.select(this).classed('over', false);
          return d.over = false;
        }).each(function(d) {
          return d.watch('over', function() {
            return svg.classed('over', d.over);
          });
        });
        src = d.audioSrc || d.src;
        if (!('_loader' in d)) {
          if ('_channel' in d) {
            d._loader = function(_, callback) {
              return callback();
            };
          } else {
            d._loader = httpSoundLoader;
          }
        }
        d._loader(loadingMessage, function() {
          var waveform;
          loadingMessage.remove();
          waveform = Waveform().x(x).height(height).verticalZoom(sequence.waveformVerticalZoom()).timeline(sequence.timeline());
          svg.call(waveform);
          return dispatch.load(d);
        });
        _uid = uid();
        playing = false;
        play = function() {
          var audioContext, audioOut, gain, offset, panner, setPan, setVolume, source, timeOffset, whenToStart;
          audioOut = sequence.audioOut();
          if (!audioOut || !d._buffer) {
            return;
          }
          audioContext = AudioContext();
          source = audioContext.createBufferSource();
          source.buffer = d._buffer;
          gain = audioContext.createGain();
          panner = audioContext.createPanner();
          setVolume = function() {
            return gain.gain.value = d.volume / 100.0;
          };
          d.watch('volume', function() {
            return setVolume();
          });
          setVolume();
          setPan = function() {
            var angle, y;
            angle = d.pan / 64 * Math.PI * 0.5;
            x = Math.sin(angle) / 2;
            y = Math.cos(angle) / 2;
            return panner.setPosition(x, y, 0);
          };
          d.watch('pan', function() {
            return setPan();
          });
          setPan();
          source.connect(gain);
          gain.connect(panner);
          panner.connect(audioOut);
          timeOffset = sequence.currentTime() - (d.startTime || 0);
          whenToStart = timeOffset < 0 ? audioContext.currentTime - timeOffset : 0;
          offset = timeOffset > 0 ? timeOffset : 0;
          source.start(whenToStart, offset);
          d.gain = gain;
          return d.source = source;
        };
        sequence.on('play.audio' + _uid, function() {
          playing = true;
          return play();
        });
        sequence.on('stop.audio' + _uid, function() {
          playing = false;
          if (!('source' in d)) {
            console.log('stopping but no source set');
          }
          if (d.source) {
            d.source.stop(0);
          }
          return delete d.source;
        });
        sequence.on('loop.audio' + _uid, function(start) {
          if (d.source) {
            d.source.stop(0);
          }
          if (playing) {
            return play();
          }
        });
        return sequence.on('volumeChange.audio' + _uid, function() {
          console.log('IS THIS VOLUME CHANGE EVENT USED (or necessary)?');
          return d.gain.gain.value = d.volume / 100.0;
        });
      });
    };
    audio.redraw = function(selection, options) {
      if (options && options.addOnsets) {
        return selection.each(function(d, i) {
          var onsets, svg;
          onsets = Onsets().x(x).timeline(sequence.timeline());
          svg = d3.select(this).select('svg');
          return svg.call(onsets);
        });
      }
    };
    audio.on = function(type, listener) {
      dispatch.on(type, listener);
      return audio;
    };
    return d3.rebind(audio, commonProperties(), 'sequence', 'height');
  };

}).call(this);

},{"../audioContext":4,"../commonProperties":6,"../components/onsets":15,"../components/waveform":24,"../prongGlobal":33,"../sound":35,"../trackName":41,"../uid":42,"d3-prong":46}],37:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Waveform, commonProperties, d3, prong, regionCounter, setPlayHandler, uid;

  d3 = require('d3-prong');

  commonProperties = require('../commonProperties');

  uid = require('../uid');

  Waveform = require('../components/waveform');

  prong = require('../');

  regionCounter = 0;


  /*
  Constructs the audio out for the track, with gain and panner, and sets up
  the event handler so that the regions will play the right audio at the right
  time when the sequence is played.
   */

  setPlayHandler = function(track) {
    var _uid, audioContext, audioOut, gain, loopHandler, panner, play, regions, setPan, setVolume, stop, trackOut;
    regions = track.regions;
    audioOut = sequence.audioOut();
    if (!audioOut) {
      return;
    }
    audioContext = prong.audioContext();
    gain = audioContext.createGain();
    panner = audioContext.createPanner();
    setVolume = function() {
      return gain.gain.value = track.volume / 100.0;
    };
    track.watch('volume', function() {
      return setVolume();
    });
    setVolume();
    setPan = function() {
      var angle, x, y;
      angle = track.pan / 64 * Math.PI * 0.5;
      x = Math.sin(angle) / 2;
      y = Math.cos(angle) / 2;
      return panner.setPosition(x, y, 0);
    };
    track.watch('pan', function() {
      return setPan();
    });
    setPan();
    gain.connect(panner);
    panner.connect(audioOut);
    trackOut = gain;
    play = function() {
      regions.forEach(stop);
      return regions.forEach(function(region) {
        var offset, playingTime, source, timeOffset, timeUntilStart, whenToStart;
        if (!region._clip) {
          return;
        }
        if (sequence.currentTime() > region.startTime + (region.clipEnd - region.clipStart)) {
          return;
        }
        timeOffset = sequence.currentTime() - (region.startTime || 0);
        timeUntilStart = timeOffset < 0 ? 0 - timeOffset : 0;
        whenToStart = timeOffset < 0 ? audioContext.currentTime - timeOffset : audioContext.currentTime;
        offset = timeOffset > region.clipStart ? timeOffset + region.clipStart : region.clipStart;
        playingTime = region.clipEnd - region.clipStart - (timeOffset > 0 ? timeOffset : 0);
        source = audioContext.createBufferSource();
        source.buffer = region._clip._buffer;
        region._source = source;
        source.connect(trackOut);
        source.start(whenToStart, offset);
        return source.stop(whenToStart + playingTime);
      });
    };
    stop = function() {
      return regions.forEach(function(region) {
        if (region._source) {
          region._source.stop(0);
          return delete region._source;
        }
      });
    };
    loopHandler = function() {
      stop();
      return play();
    };
    _uid = uid();
    sequence.on('play.region' + _uid, play);
    sequence.on('stop.region' + _uid, stop);
    return sequence.on('loop.region' + _uid, loopHandler);
  };

  module.exports = function() {
    var audioRegions, dispatch;
    dispatch = d3.dispatch('load');
    audioRegions = function(selection) {
      var sequence, waveform, width, x;
      sequence = audioRegions.sequence();
      x = sequence.x();
      width = sequence.width();
      selection.each(function(track, i) {
        var div, height, svg;
        div = d3.select(this);
        height = track.height || sequence.trackHeight() || 128;
        div.append('div').attr('class', 'trackName').append('span').text(prong.trackName);
        svg = div.append('svg').attr('height', height).attr('width', width).on('mouseover', function(d) {
          if (!prong._dragging) {
            d3.select(this).classed('over', true);
            return d.over = true;
          }
        }).on('mouseout', function(d) {
          d3.select(this).classed('over', false);
          return d.over = false;
        }).each(function(d) {
          return d.watch('over', function() {
            return svg.classed('over', d.over);
          });
        });
        svg.selectAll('g').data(track.regions).enter().append('g').attr('class', 'audioRegion').append('rect').attr('x', function(d) {
          return x(d.startTime);
        }).attr('width', function(d) {
          return x(d.clipEnd) - x(d.clipStart);
        }).attr('y', 0).attr('height', height);
        return setPlayHandler(track);
      });
      waveform = Waveform().x(x).height(sequence.trackHeight() || 128).timeline(sequence.timeline());
      selection.selectAll('g.audioRegion').each(function(d, i) {
        var container;
        container = d3.select(this);
        return sequence.pool().getClipById(d.clipId, function(clip) {
          d._clip = clip;
          container.call(waveform);
          return dispatch.load(d);
        });
      });
      return sequence.timeline().on('change.' + uid(), function() {
        return selection.selectAll('.audioRegion').selectAll('rect').attr('x', function(d) {
          return x(d.startTime);
        }).attr('width', function(d) {
          return x(d.clipEnd) - x(d.clipStart);
        });
      });
    };
    audioRegions.on = function(type, listener) {
      dispatch.on(type, listener);
      return audioRegions;
    };
    return d3.rebind(audioRegions, commonProperties(), 'sequence', 'height');
  };

}).call(this);

},{"../":28,"../commonProperties":6,"../components/waveform":24,"../uid":42,"d3-prong":46}],38:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var commonProperties, d3;

  d3 = require('d3-prong');

  commonProperties = require('../commonProperties');

  module.exports = function() {
    var dispatch, height, lyricIndexAtTime, sequence, text;
    sequence = null;
    height = null;
    dispatch = d3.dispatch('load');
    lyricIndexAtTime = function(data, time) {
      var _i, i, j, len, row;
      i = 0;
      for (_i = j = 0, len = data.length; j < len; _i = ++j) {
        row = data[_i];
        i = _i;
        if (data[i].time > time) {
          break;
        }
      }
      if (i > 0) {
        i--;
      }
      return i;
    };
    text = function(selection, options) {
      var data, display, i, play, setTimerForNextLyric, showLyric, stop, timer, uid;
      sequence = text.sequence();
      selection.append('div').attr('class', 'trackName').append('span').text(prong.trackName);
      height = selection.datum().height || sequence.trackHeight() || 128;
      display = selection.append('div').style('height', height + 'px').style('width', sequence.width() + 'px');
      display.classed('textTrack', true);
      uid = prong.uid();
      data = selection.datum().data || [];
      timer = null;
      i = null;
      showLyric = function() {
        return display.text(data[i] && data[i].text || '');
      };
      setTimerForNextLyric = function() {
        var after, currentTime, delay, hasNextLyric, nextLyric;
        if (timer) {
          clearTimeout(timer);
        }
        hasNextLyric = data.length > (i + 1);
        if (hasNextLyric) {
          nextLyric = data[i + 1];
          currentTime = sequence.currentTime();
          delay = (nextLyric.time - currentTime) * 1000;
          after = function() {
            i++;
            showLyric();
            return setTimerForNextLyric();
          };
          return timer = setTimeout(after, delay);
        }
      };
      play = function() {
        var currentTime;
        currentTime = sequence.currentTime();
        i = lyricIndexAtTime(data, currentTime);
        showLyric();
        return setTimerForNextLyric();
      };
      stop = function() {
        if (timer) {
          return clearTimeout(timer);
        }
      };
      sequence.on('play.text' + uid, play);
      sequence.on('stop.text' + uid, stop);
      sequence.on('loop.text' + uid, function(start) {
        stop();
        return play();
      });
      return sequence.timeline().on('timeselect.text' + uid, function(time) {
        i = lyricIndexAtTime(data, time);
        return showLyric();
      });
    };
    text.on = function(type, listener) {
      dispatch.on(type, listener);
      return text;
    };
    return d3.rebind(text, commonProperties(), 'sequence', 'height');
  };

}).call(this);

},{"../commonProperties":6,"d3-prong":46}],39:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var audio, audioRegions, commonProperties, createComponents, d3, fileTypesToTrackTypes, groupTracks, text, trackTypeMappings, video;

  d3 = require('d3-prong');

  commonProperties = require('../commonProperties');

  video = require('./video');

  audio = require('./audio');

  text = require('./text');

  audioRegions = require('./audioRegions');

  trackTypeMappings = {
    'audio': audio,
    'audioRegions': audioRegions,
    'video': video,
    'text': text
  };

  fileTypesToTrackTypes = {
    'mp3': 'audio',
    'wav': 'audio',
    'm4a': 'audio',
    'mp4': 'video',
    'ogg': 'video'
  };

  createComponents = function(tracks, sequence, dispatch) {
    var component, components, j, len, track;
    components = {};
    for (j = 0, len = tracks.length; j < len; j++) {
      track = tracks[j];
      if (!track.type) {
        track.type = 'audio';
      }
      if (!(track.type in components)) {
        component = trackTypeMappings[track.type]().sequence(sequence);
        if ('on' in component) {
          component.on('load', dispatch.load);
        }
        components[track.type] = component;
      }
    }
    return components;
  };

  groupTracks = function(tracks, components) {
    var component, group, groupedTracks, j, lastComponent, lastTrack, len, track;
    lastComponent = null;
    lastTrack = null;
    groupedTracks = [];
    for (j = 0, len = tracks.length; j < len; j++) {
      track = tracks[j];
      component = components[track.type];
      if (lastComponent && lastComponent === component && component.canBeGrouped) {
        lastTrack.push(track);
      } else {
        if (component.canBeGrouped) {
          group = [track];
          group.type = track.type;
          groupedTracks.push(group);
          lastTrack = group;
        } else {
          groupedTracks.push(track);
          lastTrack = track;
        }
      }
      lastComponent = component;
    }
    return groupedTracks;
  };

  module.exports = function() {
    var dispatch, track;
    dispatch = d3.dispatch('load');
    track = function(selection, options) {
      var components, groupedTracks, sel, tracks;
      tracks = selection.datum();
      components = createComponents(tracks, track.sequence(), dispatch);
      groupedTracks = groupTracks(tracks, components);
      sel = selection.selectAll('.track').data(groupedTracks).enter().append('div').attr('class', 'track');
      return sel.each(function(d, i) {
        sel = d3.select(this);
        return components[d.type](sel, options);
      });
    };
    track.on = function(type, listener) {
      return dispatch.on(type, listener);
    };
    return d3.rebind(track, commonProperties(), 'sequence');
  };

  module.exports.registerTrackType = function(type, component) {
    return trackTypeMappings[type] = component;
  };

  module.exports.unpackTrackData = function(tracks) {
    return tracks.forEach(function(track, i) {
      var fileType, trackType;
      if (typeof track === 'string') {
        fileType = track.split('.').pop();
        trackType = fileTypesToTrackTypes[fileType];
        return tracks[i] = {
          src: track,
          type: trackType
        };
      }
    });
  };

}).call(this);

},{"../commonProperties":6,"./audio":36,"./audioRegions":37,"./text":38,"./video":40,"d3-prong":46}],40:[function(require,module,exports){
d3 = require('d3-prong')

var pool = pool || {}

pool.videoTrack = function(){

    var apsectRatio,
        width,
        height = 128;

    function setup(video, canvas, offsetTime, callback){
        var x = videoTrack.x();
        var width = videoTrack.width();
        var drawingContext = canvas.node().getContext('2d');
        var startTime = Math.max(x.domain()[0], offsetTime);
        var endTime = Math.min(x.domain()[1], video.duration + offsetTime);
        var endX = x(endTime);
        aspectRatio = video.videoWidth / video.videoHeight;
        var thumbnailWidth = aspectRatio * height;
        
        var drawingWidth = x(endTime) - x(startTime);
        var frames = drawingWidth / thumbnailWidth;

        var times = d3.range(startTime, endTime, (endTime - startTime) / frames);
        var index = 0;
        var time;

        // clear the canvas
        canvas.node().width = canvas.node().width;

        function seeked(){
            var drawX = x(time);
            if ((drawX + thumbnailWidth) < endX){
                drawingContext.drawImage(video, drawX, 0, thumbnailWidth, height);
            }else{
                var fractionToDraw = (endX - drawX) / thumbnailWidth;
                drawingContext.drawImage(video, 0, 0, 
                    video.videoWidth * fractionToDraw, video.videoHeight, 
                    drawX, 0, thumbnailWidth * fractionToDraw, height);
            }
            
            nextFrame();
        }

        function nextFrame(){
            if (index > (times.length - 1)){
                video.removeEventListener('seeked', seeked);
                if (callback) callback();
            }
            time = times[index];
            index++;
            video.currentTime = time;
        }

        video.addEventListener('seeked', seeked);
        nextFrame();
    }


    function videoTrack(selection){
        selection.each(function(d,i){
            
            var target = this;
            var div = d3.select(this);
            var width = videoTrack.width();

            // we create a hidden video tag, then seek through it and pick out
            // frames to show
            var canvas = div.append('canvas')
                        .attr('height',128)
                        .attr('width',width)
                        .style('position','absolute')
                        .style('left','0px')
                        .attr('class','videoTrack');

            

            setTimeout(function(){

                console.log('adding the video element now')

                var video = d3.select('#player').append('video')
                            .attr('width',500)
                            .attr('height',280)
                            //.style('position','absolute')
                            .datum(d)

                video.append('source')
                    .attr('type','video/mp4')
                    .attr('src', d.src).node()

                video = video.node()


                d.player = video

                var preview = div.append('canvas')
                            .attr('height',128)
                            .attr('width',170)
                            .style('position','absolute')
                            .style('left','-200px')
                            .attr('class','videoPreview');

                var previewDrawingContext = preview.node().getContext('2d');

                function afterSetup(){
                    video.addEventListener('timeupdate', function(){
                        previewDrawingContext.drawImage(video, 0, 0, 170, 128)
                    })
                }

                if (video.readyState >= video.HAVE_METADATA){
                    setup(video, canvas, d.startTime, afterSetup)
                }else{
                    video.addEventListener('loadeddata', function(){
                        setup(video, canvas, d.startTime, afterSetup)
                    })
                }

                div.append('div').text(d.name).attr('class','video trackName')

            }, 0)            
        })
    };

    videoTrack.redraw = function(selection){
        selection.each(function(d,i){
            var div = d3.select(this);
            var canvas = div.select('canvas');
            var video = d.player;

            canvas.style('left','0px');

            if (video.readyState >= video.HAVE_METADATA){
                setup(video, canvas, d.startTime)
            }else{
                video.addEventListener('loadeddata', function(){
                    setup(video, canvas, d.startTime)
                })
            }

        });
    }

    return d3.rebind(videoTrack, pool.commonProperties(), 'x', 'width');
}


},{"d3-prong":46}],41:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  module.exports = function(d, i) {
    if ('name' in d) {
      return d.name;
    }
    if ('src' in d) {
      return d.src.slice(d.src.lastIndexOf('/') + 1, d.src.lastIndexOf('.')).replace('_', ' ');
    }
    return d.type;
  };

}).call(this);

},{}],42:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  module.exports = (function() {
    var id;
    id = 0;
    return function() {
      if (arguments[0] === 0) {
        id = 0;
      }
      return id++;
    };
  })();

}).call(this);

},{}],43:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var UserAgent;

  UserAgent = (function() {
    var Browsers, OS, Platform, Versions, browser_name, browser_version, os, platform;

    Versions = {
      Firefox: /firefox\/([\d\w\.\-]+)/i,
      IE: /msie\s([\d\.]+[\d])/i,
      Chrome: /chrome\/([\d\w\.\-]+)/i,
      Safari: /version\/([\d\w\.\-]+)/i,
      Ps3: /([\d\w\.\-]+)\)\s*$/i,
      Psp: /([\d\w\.\-]+)\)?\s*$/i
    };

    Browsers = {
      Konqueror: /konqueror/i,
      Chrome: /chrome/i,
      Safari: /safari/i,
      IE: /msie/i,
      Opera: /opera/i,
      PS3: /playstation 3/i,
      PSP: /playstation portable/i,
      Firefox: /firefox/i
    };

    OS = {
      WindowsVista: /windows nt 6\.0/i,
      Windows7: /windows nt 6\.\d+/i,
      Windows2003: /windows nt 5\.2/i,
      WindowsXP: /windows nt 5\.1/i,
      Windows2000: /windows nt 5\.0/i,
      OSX: /os x (\d+)[._](\d+)/i,
      Linux: /linux/i,
      Wii: /wii/i,
      PS3: /playstation 3/i,
      PSP: /playstation portable/i,
      Ipad: /\(iPad.*os (\d+)[._](\d+)/i,
      Iphone: /\(iPhone.*os (\d+)[._](\d+)/i
    };

    Platform = {
      Windows: /windows/i,
      Mac: /macintosh/i,
      Linux: /linux/i,
      Wii: /wii/i,
      Playstation: /playstation/i,
      Ipad: /ipad/i,
      Ipod: /ipod/i,
      Iphone: /iphone/i,
      Android: /android/i,
      Blackberry: /blackberry/i
    };

    function UserAgent(source) {
      if (source == null) {
        source = navigator.userAgent;
      }
      this.source = source.replace(/^\s*/, '').replace(/\s*$/, '');
      this.browser_name = browser_name(this.source);
      this.browser_version = browser_version(this.source);
      this.os = os(this.source);
      this.platform = platform(this.source);
    }

    browser_name = function(string) {
      switch (true) {
        case Browsers.Konqueror.test(string):
          return 'konqueror';
        case Browsers.Chrome.test(string):
          return 'chrome';
        case Browsers.Safari.test(string):
          return 'safari';
        case Browsers.IE.test(string):
          return 'ie';
        case Browsers.Opera.test(string):
          return 'opera';
        case Browsers.PS3.test(string):
          return 'ps3';
        case Browsers.PSP.test(string):
          return 'psp';
        case Browsers.Firefox.test(string):
          return 'firefox';
        default:
          return 'unknown';
      }
    };

    browser_version = function(string) {
      var regex;
      switch (browser_name(string)) {
        case 'chrome':
          if (Versions.Chrome.test(string)) {
            return RegExp.$1;
          }
          break;
        case 'safari':
          if (Versions.Safari.test(string)) {
            return RegExp.$1;
          }
          break;
        case 'firefox':
          if (Versions.Firefox.test(string)) {
            return RegExp.$1;
          }
          break;
        case 'ie':
          if (Versions.IE.test(string)) {
            return RegExp.$1;
          }
          break;
        case 'ps3':
          if (Versions.Ps3.test(string)) {
            return RegExp.$1;
          }
          break;
        case 'psp':
          if (Versions.Psp.test(string)) {
            return RegExp.$1;
          }
          break;
        default:
          regex = /#{name}[\/ ]([\d\w\.\-]+)/i;
          if (regex.test(string)) {
            return RegExp.$1;
          }
      }
    };

    os = function(string) {
      switch (true) {
        case OS.WindowsVista.test(string):
          return 'Windows Vista';
        case OS.Windows7.test(string):
          return 'Windows 7';
        case OS.Windows2003.test(string):
          return 'Windows 2003';
        case OS.WindowsXP.test(string):
          return 'Windows XP';
        case OS.Windows2000.test(string):
          return 'Windows 2000';
        case OS.Linux.test(string):
          return 'Linux';
        case OS.Wii.test(string):
          return 'Wii';
        case OS.PS3.test(string):
          return 'Playstation';
        case OS.PSP.test(string):
          return 'Playstation';
        case OS.OSX.test(string):
          return string.match(OS.OSX)[0].replace('_', '.');
        case OS.Ipad.test(string):
          return string.match(OS.Ipad)[0].replace('_', '.');
        case OS.Iphone.test(string):
          return string.match(OS.Iphone)[0].replace('_', '.');
        default:
          return 'unknown';
      }
    };

    platform = function(string) {
      switch (true) {
        case Platform.Windows.test(string):
          return "Microsoft Windows";
        case Platform.Mac.test(string):
          return "Apple Mac";
        case Platform.Android.test(string):
          return "Android";
        case Platform.Blackberry.test(string):
          return "Blackberry";
        case Platform.Linux.test(string):
          return "Linux";
        case Platform.Wii.test(string):
          return "Wii";
        case Platform.Playstation.test(string):
          return "Playstation";
        case Platform.Ipad.test(string):
          return "iPad";
        case Platform.Ipod.test(string):
          return "iPod";
        case Platform.Iphone.test(string):
          return "iPhone";
        default:
          return 'unknown';
      }
    };

    return UserAgent;

  })();

  module.exports = UserAgent;

}).call(this);

},{}],44:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))
},{"_process":45}],45:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],46:[function(require,module,exports){
!function(){function t(t){return null===t?0/0:+t}function n(t){return!isNaN(t)}function e(t,n){for(var e in n)Object.defineProperty(t.prototype,e,{value:n[e],enumerable:!1})}function r(){this._=Object.create(null)}function u(t){return(t+="")===Nr||t[0]===Cr?Cr+t:t}function i(t){return(t+="")[0]===Cr?t.slice(1):t}function a(t){return u(t)in this._}function o(t){return(t=u(t))in this._&&delete this._[t]}function s(){var t=[];for(var n in this._)t.push(i(n));return t}function l(){var t=0;for(var n in this._)++t;return t}function c(){for(var t in this._)return!1;return!0}function f(){this._=Object.create(null)}function h(t){for(var n=1;t*n%1;)n*=10;return n}function g(t,n,e){return function(){var r=e.apply(n,arguments);return r===n?t:r}}function p(){}function d(t,n,e){return this instanceof d?(this.h=+t,this.s=+n,void(this.l=+e)):arguments.length<2?t instanceof d?new d(t.h,t.s,t.l):C(""+t,D,d):new d(t,n,e)}function m(t,n,e){function r(t){return t>360?t-=360:0>t&&(t+=360),60>t?i+(a-i)*t/60:180>t?a:240>t?i+(a-i)*(240-t)/60:i}function u(t){return Math.round(255*r(t))}var i,a;return t=isNaN(t)?0:(t%=360)<0?t+360:t,n=isNaN(n)?0:0>n?0:n>1?1:n,e=0>e?0:e>1?1:e,a=.5>=e?e*(1+n):e+n-e*n,i=2*e-a,new A(u(t+120),u(t),u(t-120))}function v(t,n,e){return this instanceof v?(this.h=+t,this.c=+n,void(this.l=+e)):arguments.length<2?t instanceof v?new v(t.h,t.c,t.l):t instanceof _?M(t.l,t.a,t.b):M((t=F((t=Tr.rgb(t)).r,t.g,t.b)).l,t.a,t.b):new v(t,n,e)}function y(t,n,e){return isNaN(t)&&(t=0),isNaN(n)&&(n=0),new _(e,Math.cos(t*=Or)*n,Math.sin(t)*n)}function _(t,n,e){return this instanceof _?(this.l=+t,this.a=+n,void(this.b=+e)):arguments.length<2?t instanceof _?new _(t.l,t.a,t.b):t instanceof v?y(t.h,t.c,t.l):F((t=A(t)).r,t.g,t.b):new _(t,n,e)}function w(t,n,e){var r=(t+16)/116,u=r+n/500,i=r-e/200;return u=b(u)*Ir,r=b(r)*Pr,i=b(i)*Ur,new A(k(3.2404542*u-1.5371385*r-.4985314*i),k(-.969266*u+1.8760108*r+.041556*i),k(.0556434*u-.2040259*r+1.0572252*i))}function M(t,n,e){return t>0?new v(Math.atan2(e,n)*Yr,Math.sqrt(n*n+e*e),t):new v(0/0,0/0,t)}function b(t){return t>.206893034?t*t*t:(t-4/29)/7.787037}function x(t){return t>.008856?Math.pow(t,1/3):7.787037*t+4/29}function k(t){return Math.round(255*(.00304>=t?12.92*t:1.055*Math.pow(t,1/2.4)-.055))}function A(t,n,e){return this instanceof A?(this.r=~~t,this.g=~~n,void(this.b=~~e)):arguments.length<2?t instanceof A?new A(t.r,t.g,t.b):C(""+t,A,m):new A(t,n,e)}function S(t){return new A(t>>16,t>>8&255,255&t)}function T(t){return S(t)+""}function N(t){return 16>t?"0"+Math.max(0,t).toString(16):Math.min(255,t).toString(16)}function C(t,n,e){var r,u,i,a=0,o=0,s=0;if(r=/([a-z]+)\((.*)\)/i.exec(t))switch(u=r[2].split(","),r[1]){case"hsl":return e(parseFloat(u[0]),parseFloat(u[1])/100,parseFloat(u[2])/100);case"rgb":return n(j(u[0]),j(u[1]),j(u[2]))}return(i=Vr.get(t))?n(i.r,i.g,i.b):(null==t||"#"!==t.charAt(0)||isNaN(i=parseInt(t.slice(1),16))||(4===t.length?(a=(3840&i)>>4,a=a>>4|a,o=240&i,o=o>>4|o,s=15&i,s=s<<4|s):7===t.length&&(a=(16711680&i)>>16,o=(65280&i)>>8,s=255&i)),n(a,o,s))}function D(t,n,e){var r,u,i=Math.min(t/=255,n/=255,e/=255),a=Math.max(t,n,e),o=a-i,s=(a+i)/2;return o?(u=.5>s?o/(a+i):o/(2-a-i),r=t==a?(n-e)/o+(e>n?6:0):n==a?(e-t)/o+2:(t-n)/o+4,r*=60):(r=0/0,u=s>0&&1>s?0:r),new d(r,u,s)}function F(t,n,e){t=L(t),n=L(n),e=L(e);var r=x((.4124564*t+.3575761*n+.1804375*e)/Ir),u=x((.2126729*t+.7151522*n+.072175*e)/Pr),i=x((.0193339*t+.119192*n+.9503041*e)/Ur);return _(116*u-16,500*(r-u),200*(u-i))}function L(t){return(t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function j(t){var n=parseFloat(t);return"%"===t.charAt(t.length-1)?Math.round(2.55*n):n}function q(t,n){t=Tr.rgb(t),n=Tr.rgb(n);var e=t.r,r=t.g,u=t.b,i=n.r-e,a=n.g-r,o=n.b-u;return function(t){return"#"+N(Math.round(e+i*t))+N(Math.round(r+a*t))+N(Math.round(u+o*t))}}function E(t,n){var e,r={},u={};for(e in t)e in n?r[e]=z(t[e],n[e]):u[e]=t[e];for(e in n)e in t||(u[e]=n[e]);return function(t){for(e in r)u[e]=r[e](t);return u}}function O(t,n){var e,r=[],u=[],i=t.length,a=n.length,o=Math.min(t.length,n.length);for(e=0;o>e;++e)r.push(z(t[e],n[e]));for(;i>e;++e)u[e]=t[e];for(;a>e;++e)u[e]=n[e];return function(t){for(e=0;o>e;++e)u[e]=r[e](t);return u}}function Y(t,n){return t=+t,n=+n,function(e){return t*(1-e)+n*e}}function H(t,n){var e,r,u,i=Zr.lastIndex=Br.lastIndex=0,a=-1,o=[],s=[];for(t+="",n+="";(e=Zr.exec(t))&&(r=Br.exec(n));)(u=r.index)>i&&(u=n.slice(i,u),o[a]?o[a]+=u:o[++a]=u),(e=e[0])===(r=r[0])?o[a]?o[a]+=r:o[++a]=r:(o[++a]=null,s.push({i:a,x:Y(e,r)})),i=Br.lastIndex;return i<n.length&&(u=n.slice(i),o[a]?o[a]+=u:o[++a]=u),o.length<2?s[0]?(n=s[0].x,function(t){return n(t)+""}):function(){return n}:(n=s.length,function(t){for(var e,r=0;n>r;++r)o[(e=s[r]).i]=e.x(t);return o.join("")})}function z(t,n){for(var e,r=Tr.interpolators.length;--r>=0&&!(e=Tr.interpolators[r](t,n)););return e}function I(t,n){return n-=t,function(e){return Math.round(t+n*e)}}function P(t,n){return n=(n-=t=+t)||1/n,function(e){return(e-t)/n}}function U(t,n){return n=(n-=t=+t)||1/n,function(e){return Math.max(0,Math.min(1,(e-t)/n))}}function R(t){return t}function X(t,n){return n-(t?Math.ceil(Math.log(t)/Math.LN10):1)}function V(t,n){var e=Math.pow(10,3*Dr(8-n));return{scale:n>8?function(t){return t/e}:function(t){return t*e},symbol:t}}function Z(t){var n=t.decimal,e=t.thousands,r=t.grouping,u=t.currency,i=r&&e?function(t,n){for(var u=t.length,i=[],a=0,o=r[0],s=0;u>0&&o>0&&(s+o+1>n&&(o=Math.max(1,n-s)),i.push(t.substring(u-=o,u+o)),!((s+=o+1)>n));)o=r[a=(a+1)%r.length];return i.reverse().join(e)}:R;return function(t){var e=Wr.exec(t),r=e[1]||" ",a=e[2]||">",o=e[3]||"-",s=e[4]||"",l=e[5],c=+e[6],f=e[7],h=e[8],g=e[9],p=1,d="",m="",v=!1,y=!0;switch(h&&(h=+h.substring(1)),(l||"0"===r&&"="===a)&&(l=r="0",a="="),g){case"n":f=!0,g="g";break;case"%":p=100,m="%",g="f";break;case"p":p=100,m="%",g="r";break;case"b":case"o":case"x":case"X":"#"===s&&(d="0"+g.toLowerCase());case"c":y=!1;case"d":v=!0,h=0;break;case"s":p=-1,g="r"}"$"===s&&(d=u[0],m=u[1]),"r"!=g||h||(g="g"),null!=h&&("g"==g?h=Math.max(1,Math.min(21,h)):("e"==g||"f"==g)&&(h=Math.max(0,Math.min(20,h)))),g=Jr.get(g)||B;var _=l&&f;return function(t){var e=m;if(v&&t%1)return"";var u=0>t||0===t&&0>1/t?(t=-t,"-"):"-"===o?"":o;if(0>p){var s=Tr.formatPrefix(t,h);t=s.scale(t),e=s.symbol+m}else t*=p;t=g(t,h);var w,M,b=t.lastIndexOf(".");if(0>b){var x=y?t.lastIndexOf("e"):-1;0>x?(w=t,M=""):(w=t.substring(0,x),M=t.substring(x))}else w=t.substring(0,b),M=n+t.substring(b+1);!l&&f&&(w=i(w,1/0));var k=d.length+w.length+M.length+(_?0:u.length),A=c>k?new Array(k=c-k+1).join(r):"";return _&&(w=i(A+w,A.length?c-M.length:1/0)),u+=d,t=w+M,("<"===a?u+t+A:">"===a?A+u+t:"^"===a?A.substring(0,k>>=1)+u+t+A.substring(k):u+(_?t:A+t))+e}}}function B(t){return t+""}function $(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function W(t,n,e){function r(n){var e=t(n),r=i(e,1);return r-n>n-e?e:r}function u(e){return n(e=t(new Qr(e-1)),1),e}function i(t,e){return n(t=new Qr(+t),e),t}function a(t,r,i){var a=u(t),o=[];if(i>1)for(;r>a;)e(a)%i||o.push(new Date(+a)),n(a,1);else for(;r>a;)o.push(new Date(+a)),n(a,1);return o}function o(t,n,e){try{Qr=$;var r=new $;return r._=t,a(r,n,e)}finally{Qr=Date}}t.floor=t,t.round=r,t.ceil=u,t.offset=i,t.range=a;var s=t.utc=J(t);return s.floor=s,s.round=J(r),s.ceil=J(u),s.offset=J(i),s.range=o,t}function J(t){return function(n,e){try{Qr=$;var r=new $;return r._=n,t(r,e)._}finally{Qr=Date}}}function G(t){function n(t){function n(n){for(var e,u,i,a=[],o=-1,s=0;++o<r;)37===t.charCodeAt(o)&&(a.push(t.slice(s,o)),null!=(u=nu[e=t.charAt(++o)])&&(e=t.charAt(++o)),(i=N[e])&&(e=i(n,null==u?"e"===e?" ":"0":u)),a.push(e),s=o+1);return a.push(t.slice(s,o)),a.join("")}var r=t.length;return n.parse=function(n){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},u=e(r,t,n,0);if(u!=n.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var i=null!=r.Z&&Qr!==$,a=new(i?$:Qr);return"j"in r?a.setFullYear(r.y,0,r.j):"w"in r&&("W"in r||"U"in r)?(a.setFullYear(r.y,0,1),a.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(a.getDay()+5)%7:r.w+7*r.U-(a.getDay()+6)%7)):a.setFullYear(r.y,r.m,r.d),a.setHours(r.H+(r.Z/100|0),r.M+r.Z%100,r.S,r.L),i?a._:a},n.toString=function(){return t},n}function e(t,n,e,r){for(var u,i,a,o=0,s=n.length,l=e.length;s>o;){if(r>=l)return-1;if(u=n.charCodeAt(o++),37===u){if(a=n.charAt(o++),i=C[a in nu?n.charAt(o++):a],!i||(r=i(t,e,r))<0)return-1}else if(u!=e.charCodeAt(r++))return-1}return r}function r(t,n,e){b.lastIndex=0;var r=b.exec(n.slice(e));return r?(t.w=x.get(r[0].toLowerCase()),e+r[0].length):-1}function u(t,n,e){w.lastIndex=0;var r=w.exec(n.slice(e));return r?(t.w=M.get(r[0].toLowerCase()),e+r[0].length):-1}function i(t,n,e){S.lastIndex=0;var r=S.exec(n.slice(e));return r?(t.m=T.get(r[0].toLowerCase()),e+r[0].length):-1}function a(t,n,e){k.lastIndex=0;var r=k.exec(n.slice(e));return r?(t.m=A.get(r[0].toLowerCase()),e+r[0].length):-1}function o(t,n,r){return e(t,N.c.toString(),n,r)}function s(t,n,r){return e(t,N.x.toString(),n,r)}function l(t,n,r){return e(t,N.X.toString(),n,r)}function c(t,n,e){var r=_.get(n.slice(e,e+=2).toLowerCase());return null==r?-1:(t.p=r,e)}var f=t.dateTime,h=t.date,g=t.time,p=t.periods,d=t.days,m=t.shortDays,v=t.months,y=t.shortMonths;n.utc=function(t){function e(t){try{Qr=$;var n=new Qr;return n._=t,r(n)}finally{Qr=Date}}var r=n(t);return e.parse=function(t){try{Qr=$;var n=r.parse(t);return n&&n._}finally{Qr=Date}},e.toString=r.toString,e},n.multi=n.utc.multi=yn;var _=Tr.map(),w=Q(d),M=tn(d),b=Q(m),x=tn(m),k=Q(v),A=tn(v),S=Q(y),T=tn(y);p.forEach(function(t,n){_.set(t.toLowerCase(),n)});var N={a:function(t){return m[t.getDay()]},A:function(t){return d[t.getDay()]},b:function(t){return y[t.getMonth()]},B:function(t){return v[t.getMonth()]},c:n(f),d:function(t,n){return K(t.getDate(),n,2)},e:function(t,n){return K(t.getDate(),n,2)},H:function(t,n){return K(t.getHours(),n,2)},I:function(t,n){return K(t.getHours()%12||12,n,2)},j:function(t,n){return K(1+Kr.dayOfYear(t),n,3)},L:function(t,n){return K(t.getMilliseconds(),n,3)},m:function(t,n){return K(t.getMonth()+1,n,2)},M:function(t,n){return K(t.getMinutes(),n,2)},p:function(t){return p[+(t.getHours()>=12)]},S:function(t,n){return K(t.getSeconds(),n,2)},U:function(t,n){return K(Kr.sundayOfYear(t),n,2)},w:function(t){return t.getDay()},W:function(t,n){return K(Kr.mondayOfYear(t),n,2)},x:n(h),X:n(g),y:function(t,n){return K(t.getFullYear()%100,n,2)},Y:function(t,n){return K(t.getFullYear()%1e4,n,4)},Z:mn,"%":function(){return"%"}},C={a:r,A:u,b:i,B:a,c:o,d:cn,e:cn,H:hn,I:hn,j:fn,L:dn,m:ln,M:gn,p:c,S:pn,U:en,w:nn,W:rn,x:s,X:l,y:an,Y:un,Z:on,"%":vn};return n}function K(t,n,e){var r=0>t?"-":"",u=(r?-t:t)+"",i=u.length;return r+(e>i?new Array(e-i+1).join(n)+u:u)}function Q(t){return new RegExp("^(?:"+t.map(Tr.requote).join("|")+")","i")}function tn(t){for(var n=new r,e=-1,u=t.length;++e<u;)n.set(t[e].toLowerCase(),e);return n}function nn(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e,e+1));return r?(t.w=+r[0],e+r[0].length):-1}function en(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e));return r?(t.U=+r[0],e+r[0].length):-1}function rn(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e));return r?(t.W=+r[0],e+r[0].length):-1}function un(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e,e+4));return r?(t.y=+r[0],e+r[0].length):-1}function an(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e,e+2));return r?(t.y=sn(+r[0]),e+r[0].length):-1}function on(t,n,e){return/^[+-]\d{4}$/.test(n=n.slice(e,e+5))?(t.Z=-n,e+5):-1}function sn(t){return t+(t>68?1900:2e3)}function ln(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e,e+2));return r?(t.m=r[0]-1,e+r[0].length):-1}function cn(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e,e+2));return r?(t.d=+r[0],e+r[0].length):-1}function fn(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e,e+3));return r?(t.j=+r[0],e+r[0].length):-1}function hn(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e,e+2));return r?(t.H=+r[0],e+r[0].length):-1}function gn(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e,e+2));return r?(t.M=+r[0],e+r[0].length):-1}function pn(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e,e+2));return r?(t.S=+r[0],e+r[0].length):-1}function dn(t,n,e){eu.lastIndex=0;var r=eu.exec(n.slice(e,e+3));return r?(t.L=+r[0],e+r[0].length):-1}function mn(t){var n=t.getTimezoneOffset(),e=n>0?"-":"+",r=Dr(n)/60|0,u=Dr(n)%60;return e+K(r,"0",2)+K(u,"0",2)}function vn(t,n,e){ru.lastIndex=0;var r=ru.exec(n.slice(e,e+1));return r?e+r[0].length:-1}function yn(t){for(var n=t.length,e=-1;++e<n;)t[e][0]=this(t[e][0]);return function(n){for(var e=0,r=t[e];!r[1](n);)r=t[++e];return r[0](n)}}function _n(t,n,e,r){var u=e(t[0],t[1]),i=r(n[0],n[1]);return function(t){return i(u(t))}}function wn(t,n){var e,r=0,u=t.length-1,i=t[r],a=t[u];return i>a&&(e=r,r=u,u=e,e=i,i=a,a=e),t[r]=n.floor(i),t[u]=n.ceil(a),t}function Mn(t){return t?{floor:function(n){return Math.floor(n/t)*t},ceil:function(n){return Math.ceil(n/t)*t}}:iu}function bn(t,n){return n>t?-1:t>n?1:t>=n?0:0/0}function xn(t){return{left:function(n,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=n.length);u>r;){var i=r+u>>>1;t(n[i],e)<0?r=i+1:u=i}return r},right:function(n,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=n.length);u>r;){var i=r+u>>>1;t(n[i],e)>0?u=i:r=i+1}return r}}}function kn(t,n,e,r){var u=[],i=[],a=0,o=Math.min(t.length,n.length)-1;for(t[o]<t[0]&&(t=t.slice().reverse(),n=n.slice().reverse());++a<=o;)u.push(e(t[a-1],t[a])),i.push(r(n[a-1],n[a]));return function(n){var e=Tr.bisect(t,n,1,o)-1;return i[e](u[e](n))}}function An(t){var n=t[0],e=t[t.length-1];return e>n?[n,e]:[e,n]}function Sn(t){return t.rangeExtent?t.rangeExtent():An(t.range())}function Tn(t,n,e,r){function u(){var u=Math.min(t.length,n.length)>2?kn:_n,s=r?U:P;return a=u(t,n,s,e),o=u(n,t,s,z),i}function i(t){return a(t)}var a,o;return i.invert=function(t){return o(t)},i.domain=function(n){return arguments.length?(t=n.map(Number),u()):t},i.range=function(t){return arguments.length?(n=t,u()):n},i.rangeRound=function(t){return i.range(t).interpolate(I)},i.clamp=function(t){return arguments.length?(r=t,u()):r},i.interpolate=function(t){return arguments.length?(e=t,u()):e},i.ticks=function(n){return Fn(t,n)},i.tickFormat=function(n,e){return Ln(t,n,e)},i.nice=function(n){return Cn(t,n),u()},i.copy=function(){return Tn(t,n,e,r)},u()}function Nn(t,n){return Tr.rebind(t,n,"range","rangeRound","interpolate","clamp")}function Cn(t,n){return wn(t,Mn(Dn(t,n)[2]))}function Dn(t,n){null==n&&(n=10);var e=An(t),r=e[1]-e[0],u=Math.pow(10,Math.floor(Math.log(r/n)/Math.LN10)),i=n/r*u;return.15>=i?u*=10:.35>=i?u*=5:.75>=i&&(u*=2),e[0]=Math.ceil(e[0]/u)*u,e[1]=Math.floor(e[1]/u)*u+.5*u,e[2]=u,e}function Fn(t,n){return Tr.range.apply(Tr,Dn(t,n))}function Ln(t,n,e){var r=Dn(t,n);if(e){var u=Wr.exec(e);if(u.shift(),"s"===u[8]){var i=Tr.formatPrefix(Math.max(Dr(r[0]),Dr(r[1])));return u[7]||(u[7]="."+jn(i.scale(r[2]))),u[8]="f",e=Tr.format(u.join("")),function(t){return e(i.scale(t))+i.symbol}}u[7]||(u[7]="."+qn(u[8],r)),e=u.join("")}else e=",."+jn(r[2])+"f";return Tr.format(e)}function jn(t){return-Math.floor(Math.log(t)/Math.LN10+.01)}function qn(t,n){var e=jn(n[2]);return t in ou?Math.abs(e-jn(Math.max(Dr(n[0]),Dr(n[1]))))+ +("e"!==t):e-2*("%"===t)}function En(t,n,e,r){function u(t){return(e?Math.log(0>t?0:t):-Math.log(t>0?0:-t))/Math.log(n)}function i(t){return e?Math.pow(n,t):-Math.pow(n,-t)}function a(n){return t(u(n))}return a.invert=function(n){return i(t.invert(n))},a.domain=function(n){return arguments.length?(e=n[0]>=0,t.domain((r=n.map(Number)).map(u)),a):r},a.base=function(e){return arguments.length?(n=+e,t.domain(r.map(u)),a):n},a.nice=function(){var n=wn(r.map(u),e?Math:lu);return t.domain(n),r=n.map(i),a},a.ticks=function(){var t=An(r),a=[],o=t[0],s=t[1],l=Math.floor(u(o)),c=Math.ceil(u(s)),f=n%1?2:n;if(isFinite(c-l)){if(e){for(;c>l;l++)for(var h=1;f>h;h++)a.push(i(l)*h);a.push(i(l))}else for(a.push(i(l));l++<c;)for(var h=f-1;h>0;h--)a.push(i(l)*h);for(l=0;a[l]<o;l++);for(c=a.length;a[c-1]>s;c--);a=a.slice(l,c)}return a},a.tickFormat=function(t,n){if(!arguments.length)return su;arguments.length<2?n=su:"function"!=typeof n&&(n=Tr.format(n));var r,o=Math.max(.1,t/a.ticks().length),s=e?(r=1e-12,Math.ceil):(r=-1e-12,Math.floor);return function(t){return t/i(s(u(t)+r))<=o?n(t):""}},a.copy=function(){return En(t.copy(),n,e,r)},Nn(a,t)}function On(t,n,e){function r(n){return t(u(n))}var u=Yn(n),i=Yn(1/n);return r.invert=function(n){return i(t.invert(n))},r.domain=function(n){return arguments.length?(t.domain((e=n.map(Number)).map(u)),r):e},r.ticks=function(t){return Fn(e,t)},r.tickFormat=function(t,n){return Ln(e,t,n)},r.nice=function(t){return r.domain(Cn(e,t))},r.exponent=function(a){return arguments.length?(u=Yn(n=a),i=Yn(1/n),t.domain(e.map(u)),r):n},r.copy=function(){return On(t.copy(),n,e)},Nn(r,t)}function Yn(t){return function(n){return 0>n?-Math.pow(-n,t):Math.pow(n,t)}}function Hn(t,n){function e(e){return a[((i.get(e)||("range"===n.t?i.set(e,t.push(e)):0/0))-1)%a.length]}function u(n,e){return Tr.range(t.length).map(function(t){return n+e*t})}var i,a,o;return e.domain=function(u){if(!arguments.length)return t;t=[],i=new r;for(var a,o=-1,s=u.length;++o<s;)i.has(a=u[o])||i.set(a,t.push(a));return e[n.t].apply(e,n.a)},e.range=function(t){return arguments.length?(a=t,o=0,n={t:"range",a:arguments},e):a},e.rangePoints=function(r,i){arguments.length<2&&(i=0);var s=r[0],l=r[1],c=(l-s)/(Math.max(1,t.length-1)+i);return a=u(t.length<2?(s+l)/2:s+c*i/2,c),o=0,n={t:"rangePoints",a:arguments},e},e.rangeBands=function(r,i,s){arguments.length<2&&(i=0),arguments.length<3&&(s=i);var l=r[1]<r[0],c=r[l-0],f=r[1-l],h=(f-c)/(t.length-i+2*s);return a=u(c+h*s,h),l&&a.reverse(),o=h*(1-i),n={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(r,i,s){arguments.length<2&&(i=0),arguments.length<3&&(s=i);var l=r[1]<r[0],c=r[l-0],f=r[1-l],h=Math.floor((f-c)/(t.length-i+2*s)),g=f-c-(t.length-i)*h;return a=u(c+Math.round(g/2),h),l&&a.reverse(),o=Math.round(h*(1-i)),n={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return An(n.a[0])},e.copy=function(){return Hn(t,n)},e.domain(t)}function zn(t){return"function"==typeof t?t:function(){return t}}function In(){return!0}function Pn(t){return t[0]}function Un(t){return t[1]}function Rn(t){function n(n){function a(){l.push("M",i(t(c),o))}for(var s,l=[],c=[],f=-1,h=n.length,g=zn(e),p=zn(r);++f<h;)u.call(this,s=n[f],f)?c.push([+g.call(this,s,f),+p.call(this,s,f)]):c.length&&(a(),c=[]);return c.length&&a(),l.length?l.join(""):null}var e=Pn,r=Un,u=In,i=Xn,a=i.key,o=.7;return n.x=function(t){return arguments.length?(e=t,n):e},n.y=function(t){return arguments.length?(r=t,n):r},n.defined=function(t){return arguments.length?(u=t,n):u},n.interpolate=function(t){return arguments.length?(a="function"==typeof t?i=t:(i=pu.get(t)||Xn).key,n):a},n.tension=function(t){return arguments.length?(o=t,n):o},n}function Xn(t){return t.join("L")}function Vn(t){return Xn(t)+"Z"}function Zn(t){for(var n=0,e=t.length,r=t[0],u=[r[0],",",r[1]];++n<e;)u.push("H",(r[0]+(r=t[n])[0])/2,"V",r[1]);return e>1&&u.push("H",r[0]),u.join("")}function Bn(t){for(var n=0,e=t.length,r=t[0],u=[r[0],",",r[1]];++n<e;)u.push("V",(r=t[n])[1],"H",r[0]);return u.join("")}function $n(t){for(var n=0,e=t.length,r=t[0],u=[r[0],",",r[1]];++n<e;)u.push("H",(r=t[n])[0],"V",r[1]);return u.join("")}function Wn(t,n){return t.length<4?Xn(t):t[1]+Kn(t.slice(1,t.length-1),Qn(t,n))}function Jn(t,n){return t.length<3?Xn(t):t[0]+Kn((t.push(t[0]),t),Qn([t[t.length-2]].concat(t,[t[1]]),n))}function Gn(t,n){return t.length<3?Xn(t):t[0]+Kn(t,Qn(t,n))}function Kn(t,n){if(n.length<1||t.length!=n.length&&t.length!=n.length+2)return Xn(t);var e=t.length!=n.length,r="",u=t[0],i=t[1],a=n[0],o=a,s=1;if(e&&(r+="Q"+(i[0]-2*a[0]/3)+","+(i[1]-2*a[1]/3)+","+i[0]+","+i[1],u=t[1],s=2),n.length>1){o=n[1],i=t[s],s++,r+="C"+(u[0]+a[0])+","+(u[1]+a[1])+","+(i[0]-o[0])+","+(i[1]-o[1])+","+i[0]+","+i[1];for(var l=2;l<n.length;l++,s++)i=t[s],o=n[l],r+="S"+(i[0]-o[0])+","+(i[1]-o[1])+","+i[0]+","+i[1]}if(e){var c=t[s];r+="Q"+(i[0]+2*o[0]/3)+","+(i[1]+2*o[1]/3)+","+c[0]+","+c[1]}return r}function Qn(t,n){for(var e,r=[],u=(1-n)/2,i=t[0],a=t[1],o=1,s=t.length;++o<s;)e=i,i=a,a=t[o],r.push([u*(a[0]-e[0]),u*(a[1]-e[1])]);return r}function te(t){if(t.length<3)return Xn(t);var n=1,e=t.length,r=t[0],u=r[0],i=r[1],a=[u,u,u,(r=t[1])[0]],o=[i,i,i,r[1]],s=[u,",",i,"L",ue(vu,a),",",ue(vu,o)];for(t.push(t[e-1]);++n<=e;)r=t[n],a.shift(),a.push(r[0]),o.shift(),o.push(r[1]),ie(s,a,o);return t.pop(),s.push("L",r),s.join("")}function ne(t){if(t.length<4)return Xn(t);for(var n,e=[],r=-1,u=t.length,i=[0],a=[0];++r<3;)n=t[r],i.push(n[0]),a.push(n[1]);for(e.push(ue(vu,i)+","+ue(vu,a)),--r;++r<u;)n=t[r],i.shift(),i.push(n[0]),a.shift(),a.push(n[1]),ie(e,i,a);return e.join("")}function ee(t){for(var n,e,r=-1,u=t.length,i=u+4,a=[],o=[];++r<4;)e=t[r%u],a.push(e[0]),o.push(e[1]);for(n=[ue(vu,a),",",ue(vu,o)],--r;++r<i;)e=t[r%u],a.shift(),a.push(e[0]),o.shift(),o.push(e[1]),ie(n,a,o);return n.join("")}function re(t,n){var e=t.length-1;if(e)for(var r,u,i=t[0][0],a=t[0][1],o=t[e][0]-i,s=t[e][1]-a,l=-1;++l<=e;)r=t[l],u=l/e,r[0]=n*r[0]+(1-n)*(i+u*o),r[1]=n*r[1]+(1-n)*(a+u*s);return te(t)}function ue(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]}function ie(t,n,e){t.push("C",ue(du,n),",",ue(du,e),",",ue(mu,n),",",ue(mu,e),",",ue(vu,n),",",ue(vu,e))}function ae(t,n){return(n[1]-t[1])/(n[0]-t[0])}function oe(t){for(var n=0,e=t.length-1,r=[],u=t[0],i=t[1],a=r[0]=ae(u,i);++n<e;)r[n]=(a+(a=ae(u=i,i=t[n+1])))/2;return r[n]=a,r}function se(t){for(var n,e,r,u,i=[],a=oe(t),o=-1,s=t.length-1;++o<s;)n=ae(t[o],t[o+1]),Dr(n)<Er?a[o]=a[o+1]=0:(e=a[o]/n,r=a[o+1]/n,u=e*e+r*r,u>9&&(u=3*n/Math.sqrt(u),a[o]=u*e,a[o+1]=u*r));for(o=-1;++o<=s;)u=(t[Math.min(s,o+1)][0]-t[Math.max(0,o-1)][0])/(6*(1+a[o]*a[o])),i.push([u||0,a[o]*u||0]);return i}function le(t){return t.length<3?Xn(t):t[0]+Kn(t,se(t))}function ce(t){function n(n){function s(){d.push("M",o(t(v),f),c,l(t(m.reverse()),f),"Z")}for(var h,g,p,d=[],m=[],v=[],y=-1,_=n.length,w=zn(e),M=zn(u),b=e===r?function(){return g}:zn(r),x=u===i?function(){return p}:zn(i);++y<_;)a.call(this,h=n[y],y)?(m.push([g=+w.call(this,h,y),p=+M.call(this,h,y)]),v.push([+b.call(this,h,y),+x.call(this,h,y)])):m.length&&(s(),m=[],v=[]);return m.length&&s(),d.length?d.join(""):null}var e=Pn,r=Pn,u=0,i=Un,a=In,o=Xn,s=o.key,l=o,c="L",f=.7;return n.x=function(t){return arguments.length?(e=r=t,n):r},n.x0=function(t){return arguments.length?(e=t,n):e},n.x1=function(t){return arguments.length?(r=t,n):r},n.y=function(t){return arguments.length?(u=i=t,n):i},n.y0=function(t){return arguments.length?(u=t,n):u},n.y1=function(t){return arguments.length?(i=t,n):i},n.defined=function(t){return arguments.length?(a=t,n):a},n.interpolate=function(t){return arguments.length?(s="function"==typeof t?o=t:(o=pu.get(t)||Xn).key,l=o.reverse||o,c=o.closed?"M":"L",n):s},n.tension=function(t){return arguments.length?(f=t,n):f},n}function fe(t,n){if(n in t)return n;n=n.charAt(0).toUpperCase()+n.slice(1);for(var e=0,r=Au.length;r>e;++e){var u=Au[e]+n;if(u in t)return u}}function he(t){return ku(t,Du),t}function ge(t){return"function"==typeof t?t:function(){return Su(t,this)}}function pe(t){return"function"==typeof t?t:function(){return Tu(t,this)}}function de(t,n){function e(){this.removeAttribute(t)}function r(){this.removeAttributeNS(t.space,t.local)}function u(){this.setAttribute(t,n)}function i(){this.setAttributeNS(t.space,t.local,n)}function a(){var e=n.apply(this,arguments);null==e?this.removeAttribute(t):this.setAttribute(t,e)}function o(){var e=n.apply(this,arguments);null==e?this.removeAttributeNS(t.space,t.local):this.setAttributeNS(t.space,t.local,e)}return t=Tr.ns.qualify(t),null==n?t.local?r:e:"function"==typeof n?t.local?o:a:t.local?i:u}function me(t){return t.trim().replace(/\s+/g," ")}function ve(t){return new RegExp("(?:^|\\s+)"+Tr.requote(t)+"(?:\\s+|$)","g")}function ye(t){return(t+"").trim().split(/^|\s+/)}function _e(t,n){function e(){for(var e=-1;++e<u;)t[e](this,n)}function r(){for(var e=-1,r=n.apply(this,arguments);++e<u;)t[e](this,r)}t=ye(t).map(we);var u=t.length;return"function"==typeof n?r:e}function we(t){var n=ve(t);return function(e,r){if(u=e.classList)return r?u.add(t):u.remove(t);var u=e.getAttribute("class")||"";r?(n.lastIndex=0,n.test(u)||e.setAttribute("class",me(u+" "+t))):e.setAttribute("class",me(u.replace(n," ")))}}function Me(t,n,e){function r(){this.style.removeProperty(t)}function u(){this.style.setProperty(t,n,e)}function i(){var r=n.apply(this,arguments);null==r?this.style.removeProperty(t):this.style.setProperty(t,r,e)}return null==n?r:"function"==typeof n?i:u}function be(t,n){function e(){delete this[t]}function r(){this[t]=n}function u(){var e=n.apply(this,arguments);null==e?delete this[t]:this[t]=e}return null==n?e:"function"==typeof n?u:r}function xe(t){return"function"==typeof t?t:(t=Tr.ns.qualify(t)).local?function(){return this.ownerDocument.createElementNS(t.space,t.local)}:function(){return this.ownerDocument.createElementNS(this.namespaceURI,t)}}function ke(t){return{__data__:t}}function Ae(t){return function(){return Cu(this,t)}}function Se(t){return arguments.length||(t=bn),function(n,e){return n&&e?t(n.__data__,e.__data__):!n-!e}}function Te(){}function Ne(){}function Ce(t){function n(){for(var n,r=e,u=-1,i=r.length;++u<i;)(n=r[u].on)&&n.apply(this,arguments);return t}var e=[],u=new r;return n.on=function(n,r){var i,a=u.get(n);return arguments.length<2?a&&a.on:(a&&(a.on=null,e=e.slice(0,i=e.indexOf(a)).concat(e.slice(i+1)),u.remove(n)),r&&e.push(u.set(n,{on:r})),t)},n}function De(){Tr.event.preventDefault()}function Fe(){for(var t,n=Tr.event;t=n.sourceEvent;)n=t;return n}function Le(t){for(var n=new Ne,e=0,r=arguments.length;++e<r;)n[arguments[e]]=Ce(n);return n.of=function(e,r){return function(u){try{var i=u.sourceEvent=Tr.event;u.target=t,Tr.event=u,n[u.type].apply(e,r)}finally{Tr.event=i}}},n}function je(t,n,e){function r(){var n=this[a];n&&(this.removeEventListener(t,n,n.$),delete this[a])}function u(){var u=s(n,_u(arguments));r.call(this),this.addEventListener(t,this[a]=u,u.$=e),u._=n}function i(){var n,e=new RegExp("^__on([^.]+)"+Tr.requote(t)+"$");for(var r in this)if(n=r.match(e)){var u=this[r];this.removeEventListener(n[1],u,u.$),delete this[r]}}var a="__on"+t,o=t.indexOf("."),s=qe;o>0&&(t=t.slice(0,o));var l=Lu.get(t);return l&&(t=l,s=Ee),o?n?u:r:n?Te:i}function qe(t,n){return function(e){var r=Tr.event;Tr.event=e,n[0]=this.__data__;try{t.apply(this,n)}finally{Tr.event=r}}}function Ee(t,n){var e=qe(t,n);return function(t){var n=this,r=t.relatedTarget;r&&(r===n||8&r.compareDocumentPosition(n))||e.call(n,t)}}function Oe(t,n){for(var e=0,r=t.length;r>e;e++)for(var u,i=t[e],a=0,o=i.length;o>a;a++)(u=i[a])&&n(u,a,e);return t}function Ye(t){return ku(t,ju),t}function He(t){var n,e;return function(r,u,i){var a,o=t[i].update,s=o.length;for(i!=e&&(e=i,n=0),u>=n&&(n=u+1);!(a=o[n])&&++n<s;);return a}}function ze(){var t=this.__transition__;t&&++t.active}function Ie(){var t=Pe(),n=Ue()-t;n>24?(isFinite(n)&&(clearTimeout(Yu),Yu=setTimeout(Ie,n)),Ou=0):(Ou=1,Iu(Ie))}function Pe(){var t=Date.now();for(Hu=qu;Hu;)t>=Hu.t&&(Hu.f=Hu.c(t-Hu.t)),Hu=Hu.n;return t}function Ue(){for(var t,n=qu,e=1/0;n;)n.f?n=t?t.n=n.n:qu=n.n:(n.t<e&&(e=n.t),n=(t=n).n);return Eu=t,e}function Re(t,n){return ku(t,Ru),t.id=n,t}function Xe(t){var n=[t.a,t.b],e=[t.c,t.d],r=Ze(n),u=Ve(n,e),i=Ze(Be(e,n,-u))||0;n[0]*e[1]<e[0]*n[1]&&(n[0]*=-1,n[1]*=-1,r*=-1,u*=-1),this.rotate=(r?Math.atan2(n[1],n[0]):Math.atan2(-e[0],e[1]))*Yr,this.translate=[t.e,t.f],this.scale=[r,i],this.skew=i?Math.atan2(u,i)*Yr:0}function Ve(t,n){return t[0]*n[0]+t[1]*n[1]}function Ze(t){var n=Math.sqrt(Ve(t,t));return n&&(t[0]/=n,t[1]/=n),n}function Be(t,n,e){return t[0]+=e*n[0],t[1]+=e*n[1],t}function $e(t,n){var e,r=[],u=[],i=Tr.transform(t),a=Tr.transform(n),o=i.translate,s=a.translate,l=i.rotate,c=a.rotate,f=i.skew,h=a.skew,g=i.scale,p=a.scale;return o[0]!=s[0]||o[1]!=s[1]?(r.push("translate(",null,",",null,")"),u.push({i:1,x:Y(o[0],s[0])},{i:3,x:Y(o[1],s[1])})):r.push(s[0]||s[1]?"translate("+s+")":""),l!=c?(l-c>180?c+=360:c-l>180&&(l+=360),u.push({i:r.push(r.pop()+"rotate(",null,")")-2,x:Y(l,c)})):c&&r.push(r.pop()+"rotate("+c+")"),f!=h?u.push({i:r.push(r.pop()+"skewX(",null,")")-2,x:Y(f,h)}):h&&r.push(r.pop()+"skewX("+h+")"),g[0]!=p[0]||g[1]!=p[1]?(e=r.push(r.pop()+"scale(",null,",",null,")"),u.push({i:e-4,x:Y(g[0],p[0])},{i:e-2,x:Y(g[1],p[1])})):(1!=p[0]||1!=p[1])&&r.push(r.pop()+"scale("+p+")"),e=u.length,function(t){for(var n,i=-1;++i<e;)r[(n=u[i]).i]=n.x(t);return r.join("")}}function We(t,n,e,r){var u=t.id;return Oe(t,"function"==typeof e?function(t,i,a){t.__transition__[u].tween.set(n,r(e.call(t,t.__data__,i,a)))}:(e=r(e),function(t){t.__transition__[u].tween.set(n,e)}))}function Je(t){return null==t&&(t=""),function(){this.textContent=t}}function Ge(t){return function(n){return 0>=n?0:n>=1?1:t(n)}}function Ke(t){return function(n){return 1-t(1-n)}}function Qe(t){return function(n){return.5*(.5>n?t(2*n):2-t(2-2*n))}}function tr(t){return t*t}function nr(t){return t*t*t}function er(t){if(0>=t)return 0;if(t>=1)return 1;var n=t*t,e=n*t;return 4*(.5>t?e:3*(t-n)+e-.75)}function rr(t){return function(n){return Math.pow(n,t)}}function ur(t){return 1-Math.cos(t*qr)}function ir(t){return Math.pow(2,10*(t-1))}function ar(t){return 1-Math.sqrt(1-t*t)}function or(t,n){var e;return arguments.length<2&&(n=.45),arguments.length?e=n/jr*Math.asin(1/t):(t=1,e=n/4),function(r){return 1+t*Math.pow(2,-10*r)*Math.sin((r-e)*jr/n)}}function sr(t){return t||(t=1.70158),function(n){return n*n*((t+1)*n-t)}}function lr(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}function cr(t,n,e,u){var i=t.__transition__||(t.__transition__={active:0,count:0}),a=i[e];if(!a){var o=u.time;a=i[e]={tween:new r,time:o,ease:u.ease,delay:u.delay,duration:u.duration},++i.count,Tr.timer(function(r){function u(r){return i.active>e?l():(i.active=e,a.event&&a.event.start.call(t,c,n),a.tween.forEach(function(e,r){(r=r.call(t,c,n))&&d.push(r)}),void Tr.timer(function(){return p.c=s(r||1)?In:s,1},0,o))}function s(r){if(i.active!==e)return l();for(var u=r/g,o=f(u),s=d.length;s>0;)d[--s].call(t,o);return u>=1?(a.event&&a.event.end.call(t,c,n),l()):void 0}function l(){return--i.count?delete i[e]:delete t.__transition__,1}var c=t.__data__,f=a.ease,h=a.delay,g=a.duration,p=Hu,d=[];return p.t=h+o,r>=h?u(r-h):void(p.c=u)},0,o)}}function fr(t,n,e){t.attr("transform",function(t){var r=n(t);return"translate("+(isFinite(r)?r:e(t))+",0)"})}function hr(t,n,e){t.attr("transform",function(t){var r=n(t);return"translate(0,"+(isFinite(r)?r:e(t))+")"})}function gr(t){return t.innerRadius}function pr(t){return t.outerRadius}function dr(t){return t.startAngle}function mr(t){return t.endAngle}function vr(){var t=".dragsuppress-"+ ++ti,n="click"+t,e=Tr.select(bu).on("touchmove"+t,De).on("dragstart"+t,De).on("selectstart"+t,De);if(Qu){var r=Mu.style,u=r[Qu];r[Qu]="none"}return function(i){function a(){e.on(n,null)}e.on(t,null),Qu&&(r[Qu]=u),i&&(e.on(n,function(){De(),a()},!0),setTimeout(a,0))}}function yr(t,n){n.changedTouches&&(n=n.changedTouches[0]);var e=t.ownerSVGElement||t;if(e.createSVGPoint){var r=e.createSVGPoint();if(0>ni&&(bu.scrollX||bu.scrollY)){e=Tr.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var u=e[0][0].getScreenCTM();ni=!(u.f||u.e),e.remove()}return ni?(r.x=n.pageX,r.y=n.pageY):(r.x=n.clientX,r.y=n.clientY),r=r.matrixTransform(t.getScreenCTM().inverse()),[r.x,r.y]}var i=t.getBoundingClientRect();return[n.clientX-i.left-t.clientLeft,n.clientY-i.top-t.clientTop]}function _r(){return Tr.event.changedTouches[0].identifier}function wr(){return Tr.event.target}function Mr(){return bu}function br(t){return function(n,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),xr(n,e,t,r)
}}function xr(t,n,e,r){function u(){var t,n=s.status;if(!n&&Ar(s)||n>=200&&300>n||304===n){try{t=e.call(i,s)}catch(r){return void a.error.call(i,r)}a.load.call(i,t)}else a.error.call(i,s)}var i={},a=Tr.dispatch("beforesend","progress","load","error"),o={},s=new XMLHttpRequest,l=null;return!bu.XDomainRequest||"withCredentials"in s||!/^(http(s)?:)?\/\//.test(t)||(s=new XDomainRequest),"onload"in s?s.onload=s.onerror=u:s.onreadystatechange=function(){s.readyState>3&&u()},s.onprogress=function(t){var n=Tr.event;Tr.event=t;try{a.progress.call(i,s)}finally{Tr.event=n}},i.header=function(t,n){return t=(t+"").toLowerCase(),arguments.length<2?o[t]:(null==n?delete o[t]:o[t]=n+"",i)},i.mimeType=function(t){return arguments.length?(n=null==t?null:t+"",i):n},i.responseType=function(t){return arguments.length?(l=t,i):l},i.response=function(t){return e=t,i},["get","post"].forEach(function(t){i[t]=function(){return i.send.apply(i,[t].concat(_u(arguments)))}}),i.send=function(e,r,u){if(2===arguments.length&&"function"==typeof r&&(u=r,r=null),s.open(e,t,!0),null==n||"accept"in o||(o.accept=n+",*/*"),s.setRequestHeader)for(var c in o)s.setRequestHeader(c,o[c]);return null!=n&&s.overrideMimeType&&s.overrideMimeType(n),null!=l&&(s.responseType=l),null!=u&&i.on("error",u).on("load",function(t){u(null,t)}),a.beforesend.call(i,s),s.send(null==r?null:r),i},i.abort=function(){return s.abort(),i},Tr.rebind(i,a,"on"),null==r?i:i.get(kr(r))}function kr(t){return 1===t.length?function(n,e){t(null==n?e:null)}:t}function Ar(t){var n=t.responseType;return n&&"text"!==n?t.response:t.responseText}function Sr(t){return JSON.parse(t.responseText)}var Tr={version:"3.4.13"};Tr.mean=function(e,r){var u,i=0,a=e.length,o=-1,s=a;if(1===arguments.length)for(;++o<a;)n(u=t(e[o]))?i+=u:--s;else for(;++o<a;)n(u=t(r.call(e,e[o],o)))?i+=u:--s;return s?i/s:void 0},Tr.sum=function(t,e){var r,u=0,i=t.length,a=-1;if(1===arguments.length)for(;++a<i;)n(r=+t[a])&&(u+=r);else for(;++a<i;)n(r=+e.call(t,t[a],a))&&(u+=r);return u},Tr.max=function(t,n){var e,r,u=-1,i=t.length;if(1===arguments.length){for(;++u<i&&!(null!=(e=t[u])&&e>=e);)e=void 0;for(;++u<i;)null!=(r=t[u])&&r>e&&(e=r)}else{for(;++u<i&&!(null!=(e=n.call(t,t[u],u))&&e>=e);)e=void 0;for(;++u<i;)null!=(r=n.call(t,t[u],u))&&r>e&&(e=r)}return e},Tr.min=function(t,n){var e,r,u=-1,i=t.length;if(1===arguments.length){for(;++u<i&&!(null!=(e=t[u])&&e>=e);)e=void 0;for(;++u<i;)null!=(r=t[u])&&e>r&&(e=r)}else{for(;++u<i&&!(null!=(e=n.call(t,t[u],u))&&e>=e);)e=void 0;for(;++u<i;)null!=(r=n.call(t,t[u],u))&&e>r&&(e=r)}return e},Tr.extent=function(t,n){var e,r,u,i=-1,a=t.length;if(1===arguments.length){for(;++i<a&&!(null!=(e=u=t[i])&&e>=e);)e=u=void 0;for(;++i<a;)null!=(r=t[i])&&(e>r&&(e=r),r>u&&(u=r))}else{for(;++i<a&&!(null!=(e=u=n.call(t,t[i],i))&&e>=e);)e=void 0;for(;++i<a;)null!=(r=n.call(t,t[i],i))&&(e>r&&(e=r),r>u&&(u=r))}return[e,u]},Tr.map=function(t){var n=new r;if(t instanceof r)t.forEach(function(t,e){n.set(t,e)});else for(var e in t)n.set(e,t[e]);return n};var Nr="__proto__",Cr="\x00";e(r,{has:a,get:function(t){return this._[u(t)]},set:function(t,n){return this._[u(t)]=n},remove:o,keys:s,values:function(){var t=[];for(var n in this._)t.push(this._[n]);return t},entries:function(){var t=[];for(var n in this._)t.push({key:i(n),value:this._[n]});return t},size:l,empty:c,forEach:function(t){for(var n in this._)t.call(this,i(n),this._[n])}}),Tr.set=function(t){var n=new f;if(t)for(var e=0,r=t.length;r>e;++e)n.add(t[e]);return n},e(f,{has:a,add:function(t){return this._[u(t+="")]=!0,t},remove:o,values:s,size:l,empty:c,forEach:function(t){for(var n in this._)t.call(this,i(n))}}),Tr.nest=function(){function t(n,o,s){if(s>=a.length)return u?u.call(i,o):e?o.sort(e):o;for(var l,c,f,h,g=-1,p=o.length,d=a[s++],m=new r;++g<p;)(h=m.get(l=d(c=o[g])))?h.push(c):m.set(l,[c]);return n?(c=n(),f=function(e,r){c.set(e,t(n,r,s))}):(c={},f=function(e,r){c[e]=t(n,r,s)}),m.forEach(f),c}function n(t,e){if(e>=a.length)return t;var r=[],u=o[e++];return t.forEach(function(t,u){r.push({key:t,values:n(u,e)})}),u?r.sort(function(t,n){return u(t.key,n.key)}):r}var e,u,i={},a=[],o=[];return i.map=function(n,e){return t(e,n,0)},i.entries=function(e){return n(t(Tr.map,e,0),0)},i.key=function(t){return a.push(t),i},i.sortKeys=function(t){return o[a.length-1]=t,i},i.sortValues=function(t){return e=t,i},i.rollup=function(t){return u=t,i},i};var Dr=Math.abs;Tr.range=function(t,n,e){if(arguments.length<3&&(e=1,arguments.length<2&&(n=t,t=0)),(n-t)/e===1/0)throw new Error("infinite range");var r,u=[],i=h(Dr(e)),a=-1;if(t*=i,n*=i,e*=i,0>e)for(;(r=t+e*++a)>n;)u.push(r/i);else for(;(r=t+e*++a)<n;)u.push(r/i);return u},Tr.rebind=function(t,n){for(var e,r=1,u=arguments.length;++r<u;)t[e=arguments[r]]=g(t,n,n[e]);return t},Tr.color=p,p.prototype.toString=function(){return this.rgb()+""},Tr.hsl=d;var Fr=d.prototype=new p;Fr.brighter=function(t){return t=Math.pow(.7,arguments.length?t:1),new d(this.h,this.s,this.l/t)},Fr.darker=function(t){return t=Math.pow(.7,arguments.length?t:1),new d(this.h,this.s,t*this.l)},Fr.rgb=function(){return m(this.h,this.s,this.l)};var Lr=Math.PI,jr=2*Lr,qr=Lr/2,Er=1e-6,Or=Lr/180,Yr=180/Lr;Tr.hcl=v;var Hr=v.prototype=new p;Hr.brighter=function(t){return new v(this.h,this.c,Math.min(100,this.l+zr*(arguments.length?t:1)))},Hr.darker=function(t){return new v(this.h,this.c,Math.max(0,this.l-zr*(arguments.length?t:1)))},Hr.rgb=function(){return y(this.h,this.c,this.l).rgb()},Tr.lab=_;var zr=18,Ir=.95047,Pr=1,Ur=1.08883,Rr=_.prototype=new p;Rr.brighter=function(t){return new _(Math.min(100,this.l+zr*(arguments.length?t:1)),this.a,this.b)},Rr.darker=function(t){return new _(Math.max(0,this.l-zr*(arguments.length?t:1)),this.a,this.b)},Rr.rgb=function(){return w(this.l,this.a,this.b)},Tr.rgb=A;var Xr=A.prototype=new p;Xr.brighter=function(t){t=Math.pow(.7,arguments.length?t:1);var n=this.r,e=this.g,r=this.b,u=30;return n||e||r?(n&&u>n&&(n=u),e&&u>e&&(e=u),r&&u>r&&(r=u),new A(Math.min(255,n/t),Math.min(255,e/t),Math.min(255,r/t))):new A(u,u,u)},Xr.darker=function(t){return t=Math.pow(.7,arguments.length?t:1),new A(t*this.r,t*this.g,t*this.b)},Xr.hsl=function(){return D(this.r,this.g,this.b)},Xr.toString=function(){return"#"+N(this.r)+N(this.g)+N(this.b)};var Vr=Tr.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});Vr.forEach(function(t,n){Vr.set(t,S(n))}),Tr.interpolateRgb=q,Tr.interpolateObject=E,Tr.interpolateArray=O,Tr.interpolateNumber=Y,Tr.interpolateString=H;var Zr=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Br=new RegExp(Zr.source,"g");Tr.interpolate=z,Tr.interpolators=[function(t,n){var e=typeof n;return("string"===e?Vr.has(n)||/^(#|rgb\(|hsl\()/.test(n)?q:H:n instanceof p?q:Array.isArray(n)?O:"object"===e&&isNaN(n)?E:Y)(t,n)}],Tr.interpolateRound=I,Tr.round=function(t,n){return n?Math.round(t*(n=Math.pow(10,n)))/n:Math.round(t)};var $r=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"].map(V);Tr.formatPrefix=function(t,n){var e=0;return t&&(0>t&&(t*=-1),n&&(t=Tr.round(t,X(t,n))),e=1+Math.floor(1e-12+Math.log(t)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((e-1)/3)))),$r[8+e/3]};var Wr=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,Jr=Tr.map({b:function(t){return t.toString(2)},c:function(t){return String.fromCharCode(t)},o:function(t){return t.toString(8)},x:function(t){return t.toString(16)},X:function(t){return t.toString(16).toUpperCase()},g:function(t,n){return t.toPrecision(n)},e:function(t,n){return t.toExponential(n)},f:function(t,n){return t.toFixed(n)},r:function(t,n){return(t=Tr.round(t,X(t,n))).toFixed(Math.max(0,Math.min(20,X(t*(1+1e-15),n))))}});Tr.requote=function(t){return t.replace(Gr,"\\$&")};var Gr=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,Kr=Tr.time={},Qr=Date;$.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){tu.setUTCDate.apply(this._,arguments)},setDay:function(){tu.setUTCDay.apply(this._,arguments)},setFullYear:function(){tu.setUTCFullYear.apply(this._,arguments)},setHours:function(){tu.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){tu.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){tu.setUTCMinutes.apply(this._,arguments)},setMonth:function(){tu.setUTCMonth.apply(this._,arguments)},setSeconds:function(){tu.setUTCSeconds.apply(this._,arguments)},setTime:function(){tu.setTime.apply(this._,arguments)}};var tu=Date.prototype;Kr.year=W(function(t){return t=Kr.day(t),t.setMonth(0,1),t},function(t,n){t.setFullYear(t.getFullYear()+n)},function(t){return t.getFullYear()}),Kr.years=Kr.year.range,Kr.years.utc=Kr.year.utc.range,Kr.day=W(function(t){var n=new Qr(2e3,0);return n.setFullYear(t.getFullYear(),t.getMonth(),t.getDate()),n},function(t,n){t.setDate(t.getDate()+n)},function(t){return t.getDate()-1}),Kr.days=Kr.day.range,Kr.days.utc=Kr.day.utc.range,Kr.dayOfYear=function(t){var n=Kr.year(t);return Math.floor((t-n-6e4*(t.getTimezoneOffset()-n.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(t,n){n=7-n;var e=Kr[t]=W(function(t){return(t=Kr.day(t)).setDate(t.getDate()-(t.getDay()+n)%7),t},function(t,n){t.setDate(t.getDate()+7*Math.floor(n))},function(t){var e=Kr.year(t).getDay();return Math.floor((Kr.dayOfYear(t)+(e+n)%7)/7)-(e!==n)});Kr[t+"s"]=e.range,Kr[t+"s"].utc=e.utc.range,Kr[t+"OfYear"]=function(t){var e=Kr.year(t).getDay();return Math.floor((Kr.dayOfYear(t)+(e+n)%7)/7)}}),Kr.week=Kr.sunday,Kr.weeks=Kr.sunday.range,Kr.weeks.utc=Kr.sunday.utc.range,Kr.weekOfYear=Kr.sundayOfYear;var nu={"-":"",_:" ",0:"0"},eu=/^\s*\d+/,ru=/^%/;Tr.locale=function(t){return{numberFormat:Z(t),timeFormat:G(t)}};var uu=Tr.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});Tr.format=uu.numberFormat;var iu={floor:R,ceil:R};Tr.ascending=bn;var au=xn(bn);Tr.bisectLeft=au.left,Tr.bisect=Tr.bisectRight=au.right,Tr.bisector=function(t){return xn(1===t.length?function(n,e){return bn(t(n),e)}:t)},Tr.scale={},Tr.scale.linear=function(){return Tn([0,1],[0,1],z,!1)};var ou={s:1,g:1,p:1,r:1,e:1};Tr.scale.log=function(){return En(Tr.scale.linear().domain([0,1]),10,!0,[1,10])};var su=Tr.format(".0e"),lu={floor:function(t){return-Math.ceil(-t)},ceil:function(t){return-Math.floor(-t)}};Tr.scale.pow=function(){return On(Tr.scale.linear(),1,[0,1])},Tr.scale.sqrt=function(){return Tr.scale.pow().exponent(.5)},Tr.scale.ordinal=function(){return Hn([],{t:"range",a:[[]]})},Tr.scale.category10=function(){return Tr.scale.ordinal().range(cu)},Tr.scale.category20=function(){return Tr.scale.ordinal().range(fu)},Tr.scale.category20b=function(){return Tr.scale.ordinal().range(hu)},Tr.scale.category20c=function(){return Tr.scale.ordinal().range(gu)};var cu=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(T),fu=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(T),hu=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(T),gu=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(T);Tr.functor=zn,Tr.svg={},Tr.svg.line=function(){return Rn(R)};var pu=Tr.map({linear:Xn,"linear-closed":Vn,step:Zn,"step-before":Bn,"step-after":$n,basis:te,"basis-open":ne,"basis-closed":ee,bundle:re,cardinal:Gn,"cardinal-open":Wn,"cardinal-closed":Jn,monotone:le});pu.forEach(function(t,n){n.key=t,n.closed=/-closed$/.test(t)});var du=[0,2/3,1/3,0],mu=[0,1/3,2/3,0],vu=[0,1/6,2/3,1/6];Bn.reverse=$n,$n.reverse=Bn,Tr.svg.area=function(){return ce(R)};var yu=[].slice,_u=function(t){return yu.call(t)},wu=document,Mu=wu.documentElement,bu=window;try{_u(Mu.childNodes)[0].nodeType}catch(xu){_u=function(t){for(var n=t.length,e=new Array(n);n--;)e[n]=t[n];return e}}var ku={}.__proto__?function(t,n){t.__proto__=n}:function(t,n){for(var e in n)t[e]=n[e]},Au=["webkit","ms","moz","Moz","o","O"],Su=function(t,n){return n.querySelector(t)},Tu=function(t,n){return n.querySelectorAll(t)},Nu=Mu.matches||Mu[fe(Mu,"matchesSelector")],Cu=function(t,n){return Nu.call(t,n)};"function"==typeof Sizzle&&(Su=function(t,n){return Sizzle(t,n)[0]||null},Tu=Sizzle,Cu=Sizzle.matchesSelector),Tr.selection=function(){return zu};var Du=Tr.selection.prototype=[];Du.select=function(t){var n,e,r,u,i=[];t=ge(t);for(var a=-1,o=this.length;++a<o;){i.push(n=[]),n.parentNode=(r=this[a]).parentNode;for(var s=-1,l=r.length;++s<l;)(u=r[s])?(n.push(e=t.call(u,u.__data__,s,a)),e&&"__data__"in u&&(e.__data__=u.__data__)):n.push(null)}return he(i)},Du.selectAll=function(t){var n,e,r=[];t=pe(t);for(var u=-1,i=this.length;++u<i;)for(var a=this[u],o=-1,s=a.length;++o<s;)(e=a[o])&&(r.push(n=_u(t.call(e,e.__data__,o,u))),n.parentNode=e);return he(r)};var Fu={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};Tr.ns={prefix:Fu,qualify:function(t){var n=t.indexOf(":"),e=t;return n>=0&&(e=t.slice(0,n),t=t.slice(n+1)),Fu.hasOwnProperty(e)?{space:Fu[e],local:t}:t}},Du.attr=function(t,n){if(arguments.length<2){if("string"==typeof t){var e=this.node();return t=Tr.ns.qualify(t),t.local?e.getAttributeNS(t.space,t.local):e.getAttribute(t)}for(n in t)this.each(de(n,t[n]));return this}return this.each(de(t,n))},Du.classed=function(t,n){if(arguments.length<2){if("string"==typeof t){var e=this.node(),r=(t=ye(t)).length,u=-1;if(n=e.classList){for(;++u<r;)if(!n.contains(t[u]))return!1}else for(n=e.getAttribute("class");++u<r;)if(!ve(t[u]).test(n))return!1;return!0}for(n in t)this.each(_e(n,t[n]));return this}return this.each(_e(t,n))},Du.style=function(t,n,e){var r=arguments.length;if(3>r){if("string"!=typeof t){2>r&&(n="");for(e in t)this.each(Me(e,t[e],n));return this}if(2>r)return bu.getComputedStyle(this.node(),null).getPropertyValue(t);e=""}return this.each(Me(t,n,e))},Du.property=function(t,n){if(arguments.length<2){if("string"==typeof t)return this.node()[t];for(n in t)this.each(be(n,t[n]));return this}return this.each(be(t,n))},Du.text=function(t){return arguments.length?this.each("function"==typeof t?function(){var n=t.apply(this,arguments);this.textContent=null==n?"":n}:null==t?function(){this.textContent=""}:function(){this.textContent=t}):this.node().textContent},Du.html=function(t){return arguments.length?this.each("function"==typeof t?function(){var n=t.apply(this,arguments);this.innerHTML=null==n?"":n}:null==t?function(){this.innerHTML=""}:function(){this.innerHTML=t}):this.node().innerHTML},Du.append=function(t){return t=xe(t),this.select(function(){return this.appendChild(t.apply(this,arguments))})},Du.insert=function(t,n){return t=xe(t),n=ge(n),this.select(function(){return this.insertBefore(t.apply(this,arguments),n.apply(this,arguments)||null)})},Du.remove=function(){return this.each(function(){var t=this.parentNode;t&&t.removeChild(this)})},Du.data=function(t,n){function e(t,e){var u,i,a,o=t.length,f=e.length,h=Math.min(o,f),g=new Array(f),p=new Array(f),d=new Array(o);if(n){var m,v=new r,y=new Array(o);for(u=-1;++u<o;)v.has(m=n.call(i=t[u],i.__data__,u))?d[u]=i:v.set(m,i),y[u]=m;for(u=-1;++u<f;)(i=v.get(m=n.call(e,a=e[u],u)))?i!==!0&&(g[u]=i,i.__data__=a):p[u]=ke(a),v.set(m,!0);for(u=-1;++u<o;)v.get(y[u])!==!0&&(d[u]=t[u])}else{for(u=-1;++u<h;)i=t[u],a=e[u],i?(i.__data__=a,g[u]=i):p[u]=ke(a);for(;f>u;++u)p[u]=ke(e[u]);for(;o>u;++u)d[u]=t[u]}p.update=g,p.parentNode=g.parentNode=d.parentNode=t.parentNode,s.push(p),l.push(g),c.push(d)}var u,i,a=-1,o=this.length;if(!arguments.length){for(t=new Array(o=(u=this[0]).length);++a<o;)(i=u[a])&&(t[a]=i.__data__);return t}var s=Ye([]),l=he([]),c=he([]);if("function"==typeof t)for(;++a<o;)e(u=this[a],t.call(u,u.parentNode.__data__,a));else for(;++a<o;)e(u=this[a],t);return l.enter=function(){return s},l.exit=function(){return c},l},Du.datum=function(t){return arguments.length?this.property("__data__",t):this.property("__data__")},Du.filter=function(t){var n,e,r,u=[];"function"!=typeof t&&(t=Ae(t));for(var i=0,a=this.length;a>i;i++){u.push(n=[]),n.parentNode=(e=this[i]).parentNode;for(var o=0,s=e.length;s>o;o++)(r=e[o])&&t.call(r,r.__data__,o,i)&&n.push(r)}return he(u)},Du.order=function(){for(var t=-1,n=this.length;++t<n;)for(var e,r=this[t],u=r.length-1,i=r[u];--u>=0;)(e=r[u])&&(i&&i!==e.nextSibling&&i.parentNode.insertBefore(e,i),i=e);return this},Du.sort=function(t){t=Se.apply(this,arguments);for(var n=-1,e=this.length;++n<e;)this[n].sort(t);return this.order()},Tr.dispatch=function(){for(var t=new Ne,n=-1,e=arguments.length;++n<e;)t[arguments[n]]=Ce(t);return t},Ne.prototype.on=function(t,n){var e=t.indexOf("."),r="";if(e>=0&&(r=t.slice(e+1),t=t.slice(0,e)),t)return arguments.length<2?this[t].on(r):this[t].on(r,n);if(2===arguments.length){if(null==n)for(t in this)this.hasOwnProperty(t)&&this[t].on(r,null);return this}},Tr.event=null,Du.on=function(t,n,e){var r=arguments.length;if(3>r){if("string"!=typeof t){2>r&&(n=!1);for(e in t)this.each(je(e,t[e],n));return this}if(2>r)return(r=this.node()["__on"+t])&&r._;e=!1}return this.each(je(t,n,e))};var Lu=Tr.map({mouseenter:"mouseover",mouseleave:"mouseout"});Lu.forEach(function(t){"on"+t in wu&&Lu.remove(t)}),Du.each=function(t){return Oe(this,function(n,e,r){t.call(n,n.__data__,e,r)})},Du.call=function(t){var n=_u(arguments);return t.apply(n[0]=this,n),this},Du.empty=function(){return!this.node()},Du.node=function(){for(var t=0,n=this.length;n>t;t++)for(var e=this[t],r=0,u=e.length;u>r;r++){var i=e[r];if(i)return i}return null},Du.size=function(){var t=0;return Oe(this,function(){++t}),t};var ju=[];Tr.selection.enter=Ye,Tr.selection.enter.prototype=ju,ju.append=Du.append,ju.empty=Du.empty,ju.node=Du.node,ju.call=Du.call,ju.size=Du.size,ju.select=function(t){for(var n,e,r,u,i,a=[],o=-1,s=this.length;++o<s;){r=(u=this[o]).update,a.push(n=[]),n.parentNode=u.parentNode;for(var l=-1,c=u.length;++l<c;)(i=u[l])?(n.push(r[l]=e=t.call(u.parentNode,i.__data__,l,o)),e.__data__=i.__data__):n.push(null)}return he(a)},ju.insert=function(t,n){return arguments.length<2&&(n=He(this)),Du.insert.call(this,t,n)},Du.transition=function(){for(var t,n,e=Pu||++Xu,r=[],u=Uu||{time:Date.now(),ease:er,delay:0,duration:250},i=-1,a=this.length;++i<a;){r.push(t=[]);for(var o=this[i],s=-1,l=o.length;++s<l;)(n=o[s])&&cr(n,s,e,u),t.push(n)}return Re(r,e)},Du.interrupt=function(){return this.each(ze)},Tr.select=function(t){var n=["string"==typeof t?Su(t,wu):t];return n.parentNode=Mu,he([n])},Tr.selectAll=function(t){var n=_u("string"==typeof t?Tu(t,wu):t);return n.parentNode=Mu,he([n])};var qu,Eu,Ou,Yu,Hu,zu=Tr.select(Mu),Iu=bu[fe(bu,"requestAnimationFrame")]||function(t){setTimeout(t,17)};Tr.timer=function(t,n,e){var r=arguments.length;2>r&&(n=0),3>r&&(e=Date.now());var u=e+n,i={c:t,t:u,f:!1,n:null};Eu?Eu.n=i:qu=i,Eu=i,Ou||(Yu=clearTimeout(Yu),Ou=1,Iu(Ie))},Tr.timer.flush=function(){Pe(),Ue()};var Pu,Uu,Ru=[],Xu=0;Ru.call=Du.call,Ru.empty=Du.empty,Ru.node=Du.node,Ru.size=Du.size,Tr.transition=function(t){return arguments.length?Pu?t.transition():t:zu.transition()},Tr.transition.prototype=Ru,Ru.select=function(t){var n,e,r,u=this.id,i=[];t=ge(t);for(var a=-1,o=this.length;++a<o;){i.push(n=[]);for(var s=this[a],l=-1,c=s.length;++l<c;)(r=s[l])&&(e=t.call(r,r.__data__,l,a))?("__data__"in r&&(e.__data__=r.__data__),cr(e,l,u,r.__transition__[u]),n.push(e)):n.push(null)}return Re(i,u)},Ru.selectAll=function(t){var n,e,r,u,i,a=this.id,o=[];t=pe(t);for(var s=-1,l=this.length;++s<l;)for(var c=this[s],f=-1,h=c.length;++f<h;)if(r=c[f]){i=r.__transition__[a],e=t.call(r,r.__data__,f,s),o.push(n=[]);for(var g=-1,p=e.length;++g<p;)(u=e[g])&&cr(u,g,a,i),n.push(u)}return Re(o,a)},Ru.filter=function(t){var n,e,r,u=[];"function"!=typeof t&&(t=Ae(t));for(var i=0,a=this.length;a>i;i++){u.push(n=[]);for(var e=this[i],o=0,s=e.length;s>o;o++)(r=e[o])&&t.call(r,r.__data__,o,i)&&n.push(r)}return Re(u,this.id)},Tr.transform=function(t){var n=wu.createElementNS(Tr.ns.prefix.svg,"g");return(Tr.transform=function(t){if(null!=t){n.setAttribute("transform",t);var e=n.transform.baseVal.consolidate()}return new Xe(e?e.matrix:Vu)})(t)},Xe.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var Vu={a:1,b:0,c:0,d:1,e:0,f:0};Tr.interpolateTransform=$e,Ru.tween=function(t,n){var e=this.id;return arguments.length<2?this.node().__transition__[e].tween.get(t):Oe(this,null==n?function(n){n.__transition__[e].tween.remove(t)}:function(r){r.__transition__[e].tween.set(t,n)})},Ru.attr=function(t,n){function e(){this.removeAttribute(o)}function r(){this.removeAttributeNS(o.space,o.local)}function u(t){return null==t?e:(t+="",function(){var n,e=this.getAttribute(o);return e!==t&&(n=a(e,t),function(t){this.setAttribute(o,n(t))})})}function i(t){return null==t?r:(t+="",function(){var n,e=this.getAttributeNS(o.space,o.local);return e!==t&&(n=a(e,t),function(t){this.setAttributeNS(o.space,o.local,n(t))})})}if(arguments.length<2){for(n in t)this.attr(n,t[n]);return this}var a="transform"==t?$e:z,o=Tr.ns.qualify(t);return We(this,"attr."+t,n,o.local?i:u)},Ru.attrTween=function(t,n){function e(t,e){var r=n.call(this,t,e,this.getAttribute(u));return r&&function(t){this.setAttribute(u,r(t))}}function r(t,e){var r=n.call(this,t,e,this.getAttributeNS(u.space,u.local));return r&&function(t){this.setAttributeNS(u.space,u.local,r(t))}}var u=Tr.ns.qualify(t);return this.tween("attr."+t,u.local?r:e)},Ru.style=function(t,n,e){function r(){this.style.removeProperty(t)}function u(n){return null==n?r:(n+="",function(){var r,u=bu.getComputedStyle(this,null).getPropertyValue(t);return u!==n&&(r=z(u,n),function(n){this.style.setProperty(t,r(n),e)})})}var i=arguments.length;if(3>i){if("string"!=typeof t){2>i&&(n="");for(e in t)this.style(e,t[e],n);return this}e=""}return We(this,"style."+t,n,u)},Ru.styleTween=function(t,n,e){function r(r,u){var i=n.call(this,r,u,bu.getComputedStyle(this,null).getPropertyValue(t));return i&&function(n){this.style.setProperty(t,i(n),e)}}return arguments.length<3&&(e=""),this.tween("style."+t,r)},Ru.text=function(t){return We(this,"text",t,Je)},Ru.remove=function(){return this.each("end.transition",function(){var t;this.__transition__.count<2&&(t=this.parentNode)&&t.removeChild(this)})};var Zu=function(){return R},Bu=Tr.map({linear:Zu,poly:rr,quad:function(){return tr},cubic:function(){return nr},sin:function(){return ur},exp:function(){return ir},circle:function(){return ar},elastic:or,back:sr,bounce:function(){return lr}}),$u=Tr.map({"in":R,out:Ke,"in-out":Qe,"out-in":function(t){return Qe(Ke(t))}});Tr.ease=function(t){var n=t.indexOf("-"),e=n>=0?t.slice(0,n):t,r=n>=0?t.slice(n+1):"in";return e=Bu.get(e)||Zu,r=$u.get(r)||R,Ge(r(e.apply(null,yu.call(arguments,1))))},Ru.ease=function(t){var n=this.id;return arguments.length<1?this.node().__transition__[n].ease:("function"!=typeof t&&(t=Tr.ease.apply(Tr,arguments)),Oe(this,function(e){e.__transition__[n].ease=t}))},Ru.delay=function(t){var n=this.id;return arguments.length<1?this.node().__transition__[n].delay:Oe(this,"function"==typeof t?function(e,r,u){e.__transition__[n].delay=+t.call(e,e.__data__,r,u)}:(t=+t,function(e){e.__transition__[n].delay=t}))},Ru.duration=function(t){var n=this.id;return arguments.length<1?this.node().__transition__[n].duration:Oe(this,"function"==typeof t?function(e,r,u){e.__transition__[n].duration=Math.max(1,t.call(e,e.__data__,r,u))}:(t=Math.max(1,t),function(e){e.__transition__[n].duration=t}))},Ru.each=function(t,n){var e=this.id;if(arguments.length<2){var r=Uu,u=Pu;Pu=e,Oe(this,function(n,r,u){Uu=n.__transition__[e],t.call(n,n.__data__,r,u)}),Uu=r,Pu=u}else Oe(this,function(r){var u=r.__transition__[e];(u.event||(u.event=Tr.dispatch("start","end"))).on(t,n)});return this},Ru.transition=function(){for(var t,n,e,r,u=this.id,i=++Xu,a=[],o=0,s=this.length;s>o;o++){a.push(t=[]);for(var n=this[o],l=0,c=n.length;c>l;l++)(e=n[l])&&(r=Object.create(e.__transition__[u]),r.delay+=r.duration,cr(e,l,i,r)),t.push(e)}return Re(a,i)},Tr.svg.axis=function(){function t(t){t.each(function(){var t,l=Tr.select(this),c=this.__chart__||e,f=this.__chart__=e.copy(),h=null==s?f.ticks?f.ticks.apply(f,o):f.domain():s,g=null==n?f.tickFormat?f.tickFormat.apply(f,o):R:n,p=l.selectAll(".tick").data(h,f),d=p.enter().insert("g",".domain").attr("class","tick").style("opacity",Er),m=Tr.transition(p.exit()).style("opacity",Er).remove(),v=Tr.transition(p.order()).style("opacity",1),y=Math.max(u,0)+a,_=Sn(f),w=l.selectAll(".domain").data([0]),M=(w.enter().append("path").attr("class","domain"),Tr.transition(w));d.append("line"),d.append("text");var b,x,k,A,S=d.select("line"),T=v.select("line"),N=p.select("text").text(g),C=d.select("text"),D=v.select("text"),F="top"===r||"left"===r?-1:1;if("bottom"===r||"top"===r?(t=fr,b="x",k="y",x="x2",A="y2",N.attr("dy",0>F?"0em":".71em").style("text-anchor","middle"),M.attr("d","M"+_[0]+","+F*i+"V0H"+_[1]+"V"+F*i)):(t=hr,b="y",k="x",x="y2",A="x2",N.attr("dy",".32em").style("text-anchor",0>F?"end":"start"),M.attr("d","M"+F*i+","+_[0]+"H0V"+_[1]+"H"+F*i)),S.attr(A,F*u),C.attr(k,F*y),T.attr(x,0).attr(A,F*u),D.attr(b,0).attr(k,F*y),f.rangeBand){var L=f,j=L.rangeBand()/2;c=f=function(t){return L(t)+j}}else c.rangeBand?c=f:m.call(t,f,c);d.call(t,c,f),v.call(t,f,f)})}var n,e=Tr.scale.linear(),r=Wu,u=6,i=6,a=3,o=[10],s=null;return t.scale=function(n){return arguments.length?(e=n,t):e},t.orient=function(n){return arguments.length?(r=n in Ju?n+"":Wu,t):r},t.ticks=function(){return arguments.length?(o=arguments,t):o},t.tickValues=function(n){return arguments.length?(s=n,t):s},t.tickFormat=function(e){return arguments.length?(n=e,t):n},t.tickSize=function(n){var e=arguments.length;return e?(u=+n,i=+arguments[e-1],t):u},t.innerTickSize=function(n){return arguments.length?(u=+n,t):u},t.outerTickSize=function(n){return arguments.length?(i=+n,t):i},t.tickPadding=function(n){return arguments.length?(a=+n,t):a},t.tickSubdivide=function(){return arguments.length&&t},t};var Wu="bottom",Ju={top:1,right:1,bottom:1,left:1};Tr.svg.arc=function(){function t(){var t=n.apply(this,arguments),i=e.apply(this,arguments),a=r.apply(this,arguments)+Gu,o=u.apply(this,arguments)+Gu,s=(a>o&&(s=a,a=o,o=s),o-a),l=Lr>s?"0":"1",c=Math.cos(a),f=Math.sin(a),h=Math.cos(o),g=Math.sin(o);return s>=Ku?t?"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"M0,"+t+"A"+t+","+t+" 0 1,0 0,"+-t+"A"+t+","+t+" 0 1,0 0,"+t+"Z":"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"Z":t?"M"+i*c+","+i*f+"A"+i+","+i+" 0 "+l+",1 "+i*h+","+i*g+"L"+t*h+","+t*g+"A"+t+","+t+" 0 "+l+",0 "+t*c+","+t*f+"Z":"M"+i*c+","+i*f+"A"+i+","+i+" 0 "+l+",1 "+i*h+","+i*g+"L0,0Z"}var n=gr,e=pr,r=dr,u=mr;return t.innerRadius=function(e){return arguments.length?(n=zn(e),t):n},t.outerRadius=function(n){return arguments.length?(e=zn(n),t):e},t.startAngle=function(n){return arguments.length?(r=zn(n),t):r},t.endAngle=function(n){return arguments.length?(u=zn(n),t):u},t.centroid=function(){var t=(n.apply(this,arguments)+e.apply(this,arguments))/2,i=(r.apply(this,arguments)+u.apply(this,arguments))/2+Gu;return[Math.cos(i)*t,Math.sin(i)*t]},t};var Gu=-qr,Ku=jr-Er,Qu="onselectstart"in wu?null:fe(Mu.style,"userSelect"),ti=0;Tr.mouse=function(t){return yr(t,Fe())};var ni=/WebKit/.test(bu.navigator.userAgent)?-1:0;Tr.touch=function(t,n,e){if(arguments.length<3&&(e=n,n=Fe().changedTouches),n)for(var r,u=0,i=n.length;i>u;++u)if((r=n[u]).identifier===e)return yr(t,r)},Tr.behavior={},Tr.behavior.drag=function(){function t(){this.on("mousedown.drag",u).on("touchstart.drag",i)}function n(t,n,u,i,a){return function(){function o(){var t,e,r=n(h,d);r&&(t=r[0]-_[0],e=r[1]-_[1],p|=t|e,_=r,g({type:"drag",x:r[0]+l[0],y:r[1]+l[1],dx:t,dy:e}))}function s(){n(h,d)&&(v.on(i+m,null).on(a+m,null),y(p&&Tr.event.target===f),g({type:"dragend"}))}var l,c=this,f=Tr.event.target,h=c.parentNode,g=e.of(c,arguments),p=0,d=t(),m=".drag"+(null==d?"":"-"+d),v=Tr.select(u()).on(i+m,o).on(a+m,s),y=vr(),_=n(h,d);r?(l=r.apply(c,arguments),l=[l.x-_[0],l.y-_[1]]):l=[0,0],g({type:"dragstart"})}}var e=Le(t,"drag","dragstart","dragend"),r=null,u=n(Te,Tr.mouse,Mr,"mousemove","mouseup"),i=n(_r,Tr.touch,wr,"touchmove","touchend");return t.origin=function(n){return arguments.length?(r=n,t):r
},Tr.rebind(t,e,"on")},Tr.touches=function(t,n){return arguments.length<2&&(n=Fe().touches),n?_u(n).map(function(n){var e=yr(t,n);return e.identifier=n.identifier,e}):[]},Tr.xhr=br(R),Tr.json=function(t,n){return xr(t,"application/json",Sr,n)},"function"==typeof define&&define.amd?define(Tr):"object"==typeof module&&module.exports&&(module.exports=Tr)}();
},{}],47:[function(require,module,exports){
/* Copyright (c) 2012, Jens Nockert <jens@ofmlabs.org>, Jussi Kalliokoski <jussi@ofmlabs.org>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

if (!FFT) {
	var FFT = {}
}

void function (namespace) {
	"use strict"
	
	function butterfly2(output, outputOffset, outputStride, fStride, state, m) {
		var t = state.twiddle
		
		for (var i = 0; i < m; i++) {
			var s0_r = output[2 * ((outputOffset) + (outputStride) * (i))], s0_i = output[2 * ((outputOffset) + (outputStride) * (i)) + 1]
			var s1_r = output[2 * ((outputOffset) + (outputStride) * (i + m))], s1_i = output[2 * ((outputOffset) + (outputStride) * (i + m)) + 1]
			
			var t1_r = t[2 * ((0) + (fStride) * (i))], t1_i = t[2 * ((0) + (fStride) * (i)) + 1]
			
			var v1_r = s1_r * t1_r - s1_i * t1_i, v1_i = s1_r * t1_i + s1_i * t1_r
			
			var r0_r = s0_r + v1_r, r0_i = s0_i + v1_i
			var r1_r = s0_r - v1_r, r1_i = s0_i - v1_i
			
			output[2 * ((outputOffset) + (outputStride) * (i))] = r0_r, output[2 * ((outputOffset) + (outputStride) * (i)) + 1] = r0_i
			output[2 * ((outputOffset) + (outputStride) * (i + m))] = r1_r, output[2 * ((outputOffset) + (outputStride) * (i + m)) + 1] = r1_i
		}
	}
	
	function butterfly3(output, outputOffset, outputStride, fStride, state, m) {
		var t = state.twiddle
		var m1 = m, m2 = 2 * m
		var fStride1 = fStride, fStride2 = 2 * fStride
		
		var e = t[2 * ((0) + (fStride) * (m)) + 1]
		
		for (var i = 0; i < m; i++) {
			var s0_r = output[2 * ((outputOffset) + (outputStride) * (i))], s0_i = output[2 * ((outputOffset) + (outputStride) * (i)) + 1]
			
			var s1_r = output[2 * ((outputOffset) + (outputStride) * (i + m1))], s1_i = output[2 * ((outputOffset) + (outputStride) * (i + m1)) + 1]
			var t1_r = t[2 * ((0) + (fStride1) * (i))], t1_i = t[2 * ((0) + (fStride1) * (i)) + 1]
			var v1_r = s1_r * t1_r - s1_i * t1_i, v1_i = s1_r * t1_i + s1_i * t1_r
			
			var s2_r = output[2 * ((outputOffset) + (outputStride) * (i + m2))], s2_i = output[2 * ((outputOffset) + (outputStride) * (i + m2)) + 1]
			var t2_r = t[2 * ((0) + (fStride2) * (i))], t2_i = t[2 * ((0) + (fStride2) * (i)) + 1]
			var v2_r = s2_r * t2_r - s2_i * t2_i, v2_i = s2_r * t2_i + s2_i * t2_r
			
			var i0_r = v1_r + v2_r, i0_i = v1_i + v2_i
			
			var r0_r = s0_r + i0_r, r0_i = s0_i + i0_i
			output[2 * ((outputOffset) + (outputStride) * (i))] = r0_r, output[2 * ((outputOffset) + (outputStride) * (i)) + 1] = r0_i
			
			var i1_r = s0_r - i0_r * 0.5
			var i1_i = s0_i - i0_i * 0.5
			
			var i2_r = (v1_r - v2_r) * e
			var i2_i = (v1_i - v2_i) * e
			
			var r1_r = i1_r - i2_i
			var r1_i = i1_i + i2_r
			output[2 * ((outputOffset) + (outputStride) * (i + m1))] = r1_r, output[2 * ((outputOffset) + (outputStride) * (i + m1)) + 1] = r1_i
			
			var r2_r = i1_r + i2_i
			var r2_i = i1_i - i2_r
			output[2 * ((outputOffset) + (outputStride) * (i + m2))] = r2_r, output[2 * ((outputOffset) + (outputStride) * (i + m2)) + 1] = r2_i
		}
	}
	
	function butterfly4(output, outputOffset, outputStride, fStride, state, m) {
		var t = state.twiddle
		var m1 = m, m2 = 2 * m, m3 = 3 * m
		var fStride1 = fStride, fStride2 = 2 * fStride, fStride3 = 3 * fStride
		
		for (var i = 0; i < m; i++) {
			var s0_r = output[2 * ((outputOffset) + (outputStride) * (i))], s0_i = output[2 * ((outputOffset) + (outputStride) * (i)) + 1]
			
			var s1_r = output[2 * ((outputOffset) + (outputStride) * (i + m1))], s1_i = output[2 * ((outputOffset) + (outputStride) * (i + m1)) + 1]
			var t1_r = t[2 * ((0) + (fStride1) * (i))], t1_i = t[2 * ((0) + (fStride1) * (i)) + 1]
			var v1_r = s1_r * t1_r - s1_i * t1_i, v1_i = s1_r * t1_i + s1_i * t1_r
			
			var s2_r = output[2 * ((outputOffset) + (outputStride) * (i + m2))], s2_i = output[2 * ((outputOffset) + (outputStride) * (i + m2)) + 1]
			var t2_r = t[2 * ((0) + (fStride2) * (i))], t2_i = t[2 * ((0) + (fStride2) * (i)) + 1]
			var v2_r = s2_r * t2_r - s2_i * t2_i, v2_i = s2_r * t2_i + s2_i * t2_r
			
			var s3_r = output[2 * ((outputOffset) + (outputStride) * (i + m3))], s3_i = output[2 * ((outputOffset) + (outputStride) * (i + m3)) + 1]
			var t3_r = t[2 * ((0) + (fStride3) * (i))], t3_i = t[2 * ((0) + (fStride3) * (i)) + 1]
			var v3_r = s3_r * t3_r - s3_i * t3_i, v3_i = s3_r * t3_i + s3_i * t3_r
			
			var i0_r = s0_r + v2_r, i0_i = s0_i + v2_i
			var i1_r = s0_r - v2_r, i1_i = s0_i - v2_i
			var i2_r = v1_r + v3_r, i2_i = v1_i + v3_i
			var i3_r = v1_r - v3_r, i3_i = v1_i - v3_i
			
			var r0_r = i0_r + i2_r, r0_i = i0_i + i2_i
			
			if (state.inverse) {
				var r1_r = i1_r - i3_i
				var r1_i = i1_i + i3_r
			} else {
				var r1_r = i1_r + i3_i
				var r1_i = i1_i - i3_r
			}
			
			var r2_r = i0_r - i2_r, r2_i = i0_i - i2_i
			
			if (state.inverse) {
				var r3_r = i1_r + i3_i
				var r3_i = i1_i - i3_r
			} else {
				var r3_r = i1_r - i3_i
				var r3_i = i1_i + i3_r
			}
			
			output[2 * ((outputOffset) + (outputStride) * (i))] = r0_r, output[2 * ((outputOffset) + (outputStride) * (i)) + 1] = r0_i
			output[2 * ((outputOffset) + (outputStride) * (i + m1))] = r1_r, output[2 * ((outputOffset) + (outputStride) * (i + m1)) + 1] = r1_i
			output[2 * ((outputOffset) + (outputStride) * (i + m2))] = r2_r, output[2 * ((outputOffset) + (outputStride) * (i + m2)) + 1] = r2_i
			output[2 * ((outputOffset) + (outputStride) * (i + m3))] = r3_r, output[2 * ((outputOffset) + (outputStride) * (i + m3)) + 1] = r3_i
		}
	}
	
	function butterfly(output, outputOffset, outputStride, fStride, state, m, p) {
		var t = state.twiddle, n = state.n, scratch = new Float64Array(2 * p)
		
		for (var u = 0; u < m; u++) {
			for (var q1 = 0, k = u; q1 < p; q1++, k += m) {
				var x0_r = output[2 * ((outputOffset) + (outputStride) * (k))], x0_i = output[2 * ((outputOffset) + (outputStride) * (k)) + 1]
				scratch[2 * (q1)] = x0_r, scratch[2 * (q1) + 1] = x0_i
			}
			
			for (var q1 = 0, k = u; q1 < p; q1++, k += m) {
				var tOffset = 0
				
				var x0_r = scratch[2 * (0)], x0_i = scratch[2 * (0) + 1]
				output[2 * ((outputOffset) + (outputStride) * (k))] = x0_r, output[2 * ((outputOffset) + (outputStride) * (k)) + 1] = x0_i
				
				for (var q = 1; q < p; q++) {
					tOffset = (tOffset + fStride * k) % n
					
					var s0_r = output[2 * ((outputOffset) + (outputStride) * (k))], s0_i = output[2 * ((outputOffset) + (outputStride) * (k)) + 1]
					
					var s1_r = scratch[2 * (q)], s1_i = scratch[2 * (q) + 1]
					var t1_r = t[2 * (tOffset)], t1_i = t[2 * (tOffset) + 1]
					var v1_r = s1_r * t1_r - s1_i * t1_i, v1_i = s1_r * t1_i + s1_i * t1_r
					
					var r0_r = s0_r + v1_r, r0_i = s0_i + v1_i
					output[2 * ((outputOffset) + (outputStride) * (k))] = r0_r, output[2 * ((outputOffset) + (outputStride) * (k)) + 1] = r0_i
				}
			}
		}
	}
	
	function work(output, outputOffset, outputStride, f, fOffset, fStride, inputStride, factors, state) {
		var p = factors.shift()
		var m = factors.shift()
		
		if (m == 1) {
			for (var i = 0; i < p * m; i++) {
				var x0_r = f[2 * ((fOffset) + (fStride * inputStride) * (i))], x0_i = f[2 * ((fOffset) + (fStride * inputStride) * (i)) + 1]
				output[2 * ((outputOffset) + (outputStride) * (i))] = x0_r, output[2 * ((outputOffset) + (outputStride) * (i)) + 1] = x0_i
			}
		} else {
			for (var i = 0; i < p; i++) {
				work(output, outputOffset + outputStride * i * m, outputStride, f, fOffset + i * fStride * inputStride, fStride * p, inputStride, factors.slice(), state)
			}
		}
		
		switch (p) {
			case 2: butterfly2(output, outputOffset, outputStride, fStride, state, m); break
			case 3: butterfly3(output, outputOffset, outputStride, fStride, state, m); break
			case 4: butterfly4(output, outputOffset, outputStride, fStride, state, m); break
			default: butterfly(output, outputOffset, outputStride, fStride, state, m, p); break
		}
	}
	
	var complex = function (n, inverse) {
		var n = ~~n, inverse = !!inverse
		
		if (n < 1) {
			throw new RangeError("n is outside range, should be positive integer, was `" + n + "'")
		}
		
		var state = {
			n: n,
			inverse: inverse,
			
			factors: [],
			twiddle: new Float64Array(2 * n),
			scratch: new Float64Array(2 * n)
		}
		
		var t = state.twiddle, theta = 2 * Math.PI / n
		
		for (var i = 0; i < n; i++) {
			if (inverse) {
				var phase =  theta * i
			} else {
				var phase = -theta * i
			}
			
			t[2 * (i)] = Math.cos(phase)
			t[2 * (i) + 1] = Math.sin(phase)
		}
		
		var p = 4, v = Math.floor(Math.sqrt(n))
		
		while (n > 1) {
			while (n % p) {
				switch (p) {
					case 4: p = 2; break
					case 2: p = 3; break
					default: p += 2; break
				}
				
				if (p > v) {
					p = n
				}
			}
			
			n /= p
			
			state.factors.push(p)
			state.factors.push(n)
		}
		
		this.state = state
	}
	
	complex.prototype.simple = function (output, input, t) {
		this.process(output, 0, 1, input, 0, 1, t)
	}
	
	complex.prototype.process = function(output, outputOffset, outputStride, input, inputOffset, inputStride, t) {
		var outputStride = ~~outputStride, inputStride = ~~inputStride
		
		var type = t == 'real' ? t : 'complex'
		
		if (outputStride < 1) {
			throw new RangeError("outputStride is outside range, should be positive integer, was `" + outputStride + "'")
		}
		
		if (inputStride < 1) {
			throw new RangeError("inputStride is outside range, should be positive integer, was `" + inputStride + "'")
		}
		
		if (type == 'real') {
			for (var i = 0; i < this.state.n; i++) {
				var x0_r = input[inputOffset + inputStride * i]
				var x0_i = 0.0
				
				this.state.scratch[2 * (i)] = x0_r, this.state.scratch[2 * (i) + 1] = x0_i
			}
			
			work(output, outputOffset, outputStride, this.state.scratch, 0, 1, 1, this.state.factors.slice(), this.state)
		} else {
			if (input == output) {
				work(this.state.scratch, 0, 1, input, inputOffset, 1, inputStride, this.state.factors.slice(), this.state)
				
				for (var i = 0; i < this.state.n; i++) {
					var x0_r = this.state.scratch[2 * (i)], x0_i = this.state.scratch[2 * (i) + 1]
					
					output[2 * ((outputOffset) + (outputStride) * (i))] = x0_r, output[2 * ((outputOffset) + (outputStride) * (i)) + 1] = x0_i
				}
			} else {
				work(output, outputOffset, outputStride, input, inputOffset, 1, inputStride, this.state.factors.slice(), this.state)
			}
		}
	}
	
	namespace.complex = complex
}(FFT)

module.exports = FFT
},{}]},{},[1]);
