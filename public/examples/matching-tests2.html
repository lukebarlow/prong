<!DOCTYPE html>
<meta charset="utf-8">
<html>
    <head>
        <script src="../js/d3.v3.js"></script>
        <script src="../js/prong.js"></script>
        <script src="../js/audioMatchingTests.js"></script>
        <script src="../js/audioMatching.js"></script>
        <style>
BODY {
    font-family:helvetica;
    background-color:#333;
    color:white;
    padding:30px;
}

A { color : steelblue;}


TEXT {
    fill:white;
    font-size:20pt;
}

/* timeline */

.timeline path,
.timeline line {
  fill: none;
  stroke: white;
  shape-rendering: crispEdges;
}

.timeline text {
  fill:white;
  shape-rendering: crispEdges;
  font-size:12pt;
}

/* waveform */

.area {
  fill:steelblue;
}

.line {
  stroke:steelblue;
  fill:none;
}

.onsets rect {
    fill:white;
}
        </style>
    </head>
    <body>
        <div id="tests"></div>
        <script>


var height = 32;

var y = d3.scale.linear()
    .range([height,0])
    .domain([1,-1]);

var width = 1200;

function waveformY(i){
    return (10 + i * height)
}

function applyEffects(channel){

    // var thinned = fx.thinOut(channel, 5000);
    // thinned[thinned.length-1] = thinned[thinned.length-2];
    // var min = d3.min(thinned);

    // console.log(min)

    // channel = channel.map(function(d){
    //     return Math.max(0, d - min)}
    // );

    prong.fx.normalise(channel);
    //prong.fx.compression(channel, testSettings.compression)
    
    
    return channel
}

var tracks;

function drawLines(container, timeline, tracks, key, colour){
    var component = prong.lines()
        .x(x)
        .height(height)
        .timeline(timeline)
        .colour('red')
        .key('onsetTimes');

    testContainer.append('g')
        .attr('class','onsets')
        .selectAll('g')
        .data(tracks)
        .enter()
        .append('g')
        .attr('transform',function(d,i){
            return 'translate(0,' + waveformY(i) + ')'
        })
        .call(onsets)
}

function runTest(test, callback){

    var testContainer = d3.select('#tests').append('svg')
        .style('height', (2*height+20) + 'px');
    var x = d3.scale.linear().domain([0, 80]).range([0, width]);
    var timeline = prong.timeline()
        .x(x)
        .scrollZone(testContainer);

    var waveform = prong.waveform()
        .x(x)
        .height(height)
        .timeline(timeline);

    prong.sounds([test.a, test.b], function(buffers){
        // draw the tracks
        tracks = buffers.map(function(buffer){
            return {
                buffer : buffer,
                channel : applyEffects(buffer.getChannelData(0))
            }
        })

        testContainer.append('g').call(timeline);
        testContainer.append('g').selectAll('g')
            .data(tracks)
            .enter()
            .append('g')
            .attr('class','waveform')
            .attr('transform',function(d,i){
                return 'translate(0,' + waveformY(i) + ')'
            })
            .call(waveform)

        var round3 = function(x){return d3.round(x,3)};

        // now work out the onsets
        tracks.forEach(function(track){
            var topology = prong.noteOnset(track.channel, track.buffer.sampleRate)
            var onsetTimes = topology.onsets;
            var noteOffTimes = topology.noteOffs;
            var onsetDiffs = d3.map()
            var decimalPlaces = 3

            var timesToMatch = onsetTimes;

            for (var i=1;i<timesToMatch.length;i++){
                //var lookBack = Math.min()
                for (j=1;j<=Math.min(i,200);j++){
                //for (j=1;j<=(Math.min(i,20));j++){
                    onsetDiffs.set(d3.round(timesToMatch[i]-timesToMatch[i-j],decimalPlaces),d3.round(timesToMatch[i], decimalPlaces));
                }
            }

            // console.log('number of diffs')
            // console.log(onsetDiffs.values().length)

            //track.mins = mins;
            //track.maxes = topology.maxes.map(function(a){return a.position});
            track.onsetTimes = onsetTimes;
            track.noteOffTimes = noteOffTimes;
            track.minima = topology.minima;
            track.maxima = topology.maxima;
            track.onsetDiffs = onsetDiffs;
        })

        var time = calculateBestStartTimes(tracks);

        function drawLines(key, colour){

            var component = prong.lines()
                .x(x)
                .height(height)
                .timeline(timeline)
                .colour(colour)
                .key(key);

            testContainer.append('g')
                .attr('class','onsets')
                .selectAll('g')
                .data(tracks)
                .enter()
                .append('g')
                .attr('transform',function(d,i){
                    return 'translate(0,' + waveformY(i) + ')'
                })
                .call(component)
        }

        drawLines('onsetTimes', 'red')
        drawLines('noteOffTimes', 'green')
        drawLines('matchingTimes', 'pink')

        testContainer.selectAll('g.waveform')
            .attr('transform',function(d,i){
                return 'translate('+x(d.startTime)+',' + waveformY(i) + ')'
            })

        timeline.on('change.resize' + prong.uid(), function(){
            testContainer.selectAll('g.waveform').attr('transform',function(d,i){
                return 'translate(0,' + waveformY(i) + ')'
            })

            testContainer.selectAll('g.waveform')
                .append('rect')
                .attr('fill','red')
                .attr('height',1)
                .attr('width',width)
                .attr('x',0)
                .attr('y',y(-0.15))
        })

        testContainer.append('text')
            .attr('width','300')
            .attr('height','150')
            .attr('x','150')
            .attr('y','64')
            .text(time)

        testContainer.style('background-color',
            time == test.offset ? '#040' : 
            (Math.abs(time - test.offset) < 0.025) ? '#dd8C00' :
            (time == 0) ? 'black' : '#400');

        //console.log(tracks);

        //setTimeout(callback, 1000);
        callback();

    })
}


function runTests(tests){
    var testIndex = 0;

    function runNextTest(){
        var test = tests[testIndex];
        runTest(test, function(){
            testIndex++;
            if (testIndex < tests.length) runNextTest();
        })
    }
    runNextTest();
}

runTests(tests);

        </script>
    </body>
</html>